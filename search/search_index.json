{"config":{"lang":["en"],"separator":"[\\s\\-\\_\\.\\(\\)\\[\\]\\/]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"depkeeper","text":"<p>Modern, intelligent Python dependency management for <code>requirements.txt</code> files.</p> <p>Keep your dependencies up-to-date and conflict-free -- without switching from pip.</p> <p> Install  Get Started  GitHub</p>"},{"location":"#why-depkeeper","title":"Why depkeeper?","text":"<p>Managing Python dependencies shouldn't be painful. While <code>pip</code> is simple and Poetry is powerful, depkeeper bridges the gap -- giving you smart automation without abandoning your existing workflow.</p> <ul> <li> Smart Updates</li> </ul> <p>Automatically discover available updates with intelligent recommendations that respect semantic versioning boundaries.</p> <ul> <li> Safe by Default</li> </ul> <p>Never accidentally cross major version boundaries. depkeeper keeps your environment stable while staying current.</p> <ul> <li> Conflict Resolution</li> </ul> <p>Detect and resolve dependency conflicts before they break your builds.</p> <ul> <li> Fast &amp; Concurrent</li> </ul> <p>Async PyPI queries maximize performance. Check hundreds of packages in seconds.</p> <ul> <li> Multiple Formats</li> </ul> <p>Output as beautiful tables, simple text, or JSON for seamless CI/CD integration.</p> <ul> <li> Pip Compatible</li> </ul> <p>Works alongside pip, not instead of it. No need to change your workflow.</p>"},{"location":"#quick-example","title":"Quick Example","text":"Bash<pre><code># Check for available updates\n$ depkeeper check\n\nChecking requirements.txt...\nFound 5 package(s)\n\nPackage       Current    Latest     Recommended  Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nrequests      2.28.0     2.32.0     2.32.0       Outdated (minor)\nflask         2.0.0      3.0.1      2.3.3        Outdated (patch)\nclick         8.0.0      8.1.7      8.1.7        Outdated (minor)\ndjango        3.2.0      5.0.2      3.2.24       Outdated (patch)\npytest        7.4.0      8.0.0      7.4.4        Outdated (patch)\n\n\u2713 Found 5 packages with available updates\n</code></pre> Bash<pre><code># Update all packages safely\n$ depkeeper update\n\nUpdating requirements.txt...\n\nPackage       Current    \u2192  Recommended  Type\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nrequests      2.28.0     \u2192  2.32.0       minor\nflask         2.0.0      \u2192  2.3.3        patch\nclick         8.0.0      \u2192  8.1.7        minor\n\nApply 3 updates? [y/N]: y\n\n\u2713 Successfully updated 3 packages\n</code></pre>"},{"location":"#feature-comparison","title":"Feature Comparison","text":"Feature pip Poetry depkeeper Simple workflow \u2705 \u26a0\ufe0f \u2705 Dependency resolution \u274c \u2705 \u2705 Update recommendations \u274c \u26a0\ufe0f \u2705 Major version boundaries \u274c \u274c \u2705 Conflict detection \u274c \u2705 \u2705 CI/CD friendly \u2705 \u2705 \u2705 requirements.txt support \u2705 \u274c \u2705 No lock-in \u2705 \u274c \u2705"},{"location":"#installation","title":"Installation","text":"pippipx (isolated)From source Bash<pre><code>pip install depkeeper\n</code></pre> Bash<pre><code>pipx install depkeeper\n</code></pre> Bash<pre><code>git clone https://github.com/rahulkaushal04/depkeeper.git\ncd depkeeper\npip install -e .\n</code></pre>"},{"location":"#whats-next","title":"What's Next?","text":"<ul> <li> Quick Start</li> </ul> <p>Get up and running in 5 minutes with the essentials.</p> <ul> <li> User Guide</li> </ul> <p>Deep dive into all features and workflows.</p> <ul> <li> API Reference</li> </ul> <p>Integrate depkeeper programmatically.</p> <ul> <li> Contributing</li> </ul> <p>Help make depkeeper even better.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>Built with amazing open source libraries:</p> <ul> <li>Click -- CLI framework</li> <li>Rich -- Beautiful terminal formatting</li> <li>httpx -- Async HTTP client</li> <li>packaging -- PEP 440/508 compliance</li> </ul> <p>Inspired by pip-tools, Poetry, and Dependabot.</p> <p>Ready to simplify your dependency management?</p> <p> Get Started</p>"},{"location":"community/","title":"Community","text":"<p>Welcome to the depkeeper community. This section covers how to get involved, stay informed about releases, and find answers to common questions.</p>"},{"location":"community/#get-involved","title":"Get Involved","text":"<p>depkeeper is an open source project and we welcome contributions of all kinds. Whether you want to report a bug, suggest a feature, improve documentation, or submit code, there are many ways to participate.</p> <ul> <li>Report issues -- Found a bug or have a feature request? Open an issue on GitHub</li> <li>Contribute code -- See the Contributing Guide for setup instructions and guidelines</li> <li>Improve docs -- Documentation improvements are always welcome</li> </ul>"},{"location":"community/#quick-links","title":"Quick Links","text":"Resource Description FAQ Answers to common questions about installation, usage, and configuration Changelog Version history and release notes License Apache 2.0 licensing details and third-party dependencies Code of Conduct Community standards and expectations Security Policy How to report vulnerabilities and what to expect"},{"location":"community/#project-links","title":"Project Links","text":"<ul> <li>Repository -- github.com/rahulkaushal04/depkeeper</li> <li>PyPI -- pypi.org/project/depkeeper</li> <li>Documentation -- rahulkaushal04.github.io/depkeeper</li> <li>Issue Tracker -- GitHub Issues</li> <li>GitHub Releases -- Releases</li> </ul>"},{"location":"community/changelog/","title":"Changelog","text":"<p>All notable changes to depkeeper are documented on this page. The format is based on Keep a Changelog, and the project adheres to Semantic Versioning.</p>"},{"location":"community/changelog/#unreleased","title":"Unreleased","text":""},{"location":"community/changelog/#planned","title":"Planned","text":"<ul> <li>Security vulnerability scanning against known advisory databases</li> <li>Lock file generation with integrity verification</li> <li>Health scoring for packages</li> </ul>"},{"location":"community/changelog/#010-2026-02-10","title":"0.1.0 -- 2026-02-10","text":"<p>Initial release of depkeeper.</p>"},{"location":"community/changelog/#check-command","title":"Check Command","text":"<ul> <li>Analyze <code>requirements.txt</code> for available updates</li> <li>Table, simple, and JSON output formats via <code>--format</code></li> <li>Filter to show only outdated packages with <code>--outdated-only</code></li> <li>Strict version matching mode with <code>--strict-version-matching</code></li> <li>Dependency conflict detection with <code>--check-conflicts</code></li> </ul>"},{"location":"community/changelog/#update-command","title":"Update Command","text":"<ul> <li>Apply safe version updates to <code>requirements.txt</code></li> <li>Dry-run mode for previewing changes with <code>--dry-run</code></li> <li>Backup creation before updates with <code>--backup</code></li> <li>Selective package updates with <code>-p</code> flag</li> <li>Confirmation prompt (skip with <code>-y</code>)</li> <li>Conflict resolution during updates</li> </ul>"},{"location":"community/changelog/#dependency-resolution","title":"Dependency Resolution","text":"<ul> <li>Build dependency graph from PyPI metadata</li> <li>Identify version conflicts between packages</li> <li>Iterative version adjustment to resolve conflicts</li> <li>Strict major version boundary enforcement -- updates never cross major versions</li> </ul>"},{"location":"community/changelog/#requirements-parser","title":"Requirements Parser","text":"<p>Full PEP 440/508 compliance with support for:</p> <ul> <li>Version specifiers: <code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>~=</code>, <code>!=</code></li> <li>Extras: <code>package[extra1,extra2]</code></li> <li>Environment markers: <code>; python_version &gt;= '3.8'</code></li> <li>Include directives: <code>-r requirements.txt</code></li> <li>Constraint files: <code>-c constraints.txt</code></li> <li>VCS URLs: <code>git+https://github.com/user/repo.git</code></li> <li>Editable installs: <code>-e .</code></li> <li>Hash verification: <code>--hash=sha256:...</code></li> </ul>"},{"location":"community/changelog/#performance","title":"Performance","text":"<ul> <li>Async concurrent PyPI queries via httpx with HTTP/2 support</li> <li>Shared data store to minimize redundant API calls</li> </ul>"},{"location":"community/changelog/#cli-experience","title":"CLI Experience","text":"<ul> <li>Rich terminal formatting with colors via the Rich library</li> <li>Progress indicators for long-running operations</li> <li>Multiple output formats (table, simple, JSON)</li> <li>Configurable verbosity levels (<code>-v</code>, <code>-vv</code>)</li> <li>Colored output toggle with <code>--color</code> / <code>--no-color</code></li> </ul>"},{"location":"community/changelog/#technical-details","title":"Technical Details","text":"<ul> <li>Minimum Python version: 3.8</li> <li>Core dependencies: Click, Rich, httpx, packaging</li> <li>Full type hints with mypy strict mode</li> <li>85%+ test coverage</li> </ul>"},{"location":"community/changelog/#version-history","title":"Version History","text":"Version Date Highlights 0.1.0 2026-02-10 Initial release with check, update, and conflict resolution"},{"location":"community/changelog/#upgrade-notes","title":"Upgrade Notes","text":""},{"location":"community/changelog/#upgrading-to-010","title":"Upgrading to 0.1.0","text":"<p>This is the initial release. Install with:</p> Bash<pre><code>pip install depkeeper\n</code></pre>"},{"location":"community/code-of-conduct/","title":"Code of Conduct","text":"<p>This page outlines the standards of behavior expected from all participants in the depkeeper community. We are committed to providing a welcoming, inclusive, and harassment-free environment for everyone.</p> <p>This Code of Conduct is adapted from the Contributor Covenant v2.1.</p>"},{"location":"community/code-of-conduct/#our-pledge","title":"Our Pledge","text":"<p>As members, contributors, and maintainers of depkeeper, we pledge to foster an open, welcoming, inclusive, and harassment-free environment for everyone, regardless of age, body size, disability, ethnicity, gender identity, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"community/code-of-conduct/#our-standards","title":"Our Standards","text":""},{"location":"community/code-of-conduct/#expected-behavior","title":"Expected Behavior","text":"<ul> <li>Demonstrate empathy, respect, and kindness toward others</li> <li>Welcome new contributors and support their learning</li> <li>Give and accept constructive feedback gracefully</li> <li>Take responsibility and apologize when mistakes occur</li> <li>Focus on what benefits the community as a whole</li> </ul>"},{"location":"community/code-of-conduct/#unacceptable-behavior","title":"Unacceptable Behavior","text":"<ul> <li>Sexualized language, imagery, or inappropriate attention</li> <li>Trolling, insulting, or derogatory comments</li> <li>Personal, political, or religious attacks</li> <li>Public or private harassment</li> <li>Publishing private information without explicit permission</li> <li>Any behavior that would be considered inappropriate in a professional setting</li> </ul>"},{"location":"community/code-of-conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all depkeeper community spaces, including GitHub Issues, Pull Requests, Discussions, and any public space where someone represents the project. Representation includes using an official project email, posting via a project account, or speaking at events on behalf of depkeeper.</p>"},{"location":"community/code-of-conduct/#enforcement","title":"Enforcement","text":"<p>If you experience or witness unacceptable behavior, report it through the channels described in the Security Policy. All reports will be reviewed promptly, fairly, and confidentially.</p>"},{"location":"community/code-of-conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders follow these guidelines when addressing violations.</p>"},{"location":"community/code-of-conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Minor inappropriate behavior or first-time offense.</p> <p>Consequence: Private written warning explaining the violation and expected behavior. A public apology may be requested.</p>"},{"location":"community/code-of-conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: Repeated violations or more serious behavior.</p> <p>Consequence: Formal warning with clear consequences for continued behavior. The individual may be asked to avoid interaction with affected parties for a specified period.</p>"},{"location":"community/code-of-conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: Serious or sustained violations.</p> <p>Consequence: Temporary ban from participation in all community spaces. Any attempt to circumvent the ban may result in escalation.</p>"},{"location":"community/code-of-conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Pattern of sustained inappropriate behavior, harassment, or discrimination.</p> <p>Consequence: Permanent ban from all community participation.</p>"},{"location":"community/code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant v2.1. Community Impact Guidelines were inspired by Mozilla's Code of Conduct Enforcement Ladder.</p>"},{"location":"community/faq/","title":"Frequently Asked Questions","text":"<p>This page answers common questions about depkeeper. If your question is not covered here, check the Troubleshooting Guide or open an issue on GitHub.</p>"},{"location":"community/faq/#general","title":"General","text":""},{"location":"community/faq/#what-is-depkeeper","title":"What is depkeeper?","text":"<p>depkeeper is a modern Python dependency management tool that helps you keep your <code>requirements.txt</code> files up-to-date and conflict-free. It analyzes your dependencies, checks for available updates, resolves conflicts, and applies safe upgrades.</p>"},{"location":"community/faq/#how-is-depkeeper-different-from-pip-tools","title":"How is depkeeper different from pip-tools?","text":"<p>depkeeper focuses on intelligent update checking and dependency conflict resolution, while pip-tools focuses on compiling and syncing dependencies.</p> Feature depkeeper pip-tools Update checking Yes, built-in Manual Dependency conflict resolution Yes, automatic No Safe major version boundaries Yes, enforced No Multiple output formats Yes (table, simple, JSON) No Dry-run mode Yes Yes"},{"location":"community/faq/#how-is-depkeeper-different-from-poetry","title":"How is depkeeper different from poetry?","text":"<p>depkeeper is designed for projects using <code>requirements.txt</code>, while poetry uses <code>pyproject.toml</code>. depkeeper is non-invasive and works alongside pip without changing your existing workflow or project structure.</p>"},{"location":"community/faq/#is-depkeeper-free","title":"Is depkeeper free?","text":"<p>Yes. depkeeper is open source and free to use under the Apache License 2.0.</p>"},{"location":"community/faq/#installation","title":"Installation","text":""},{"location":"community/faq/#what-python-version-do-i-need","title":"What Python version do I need?","text":"<p>depkeeper requires Python 3.8 or later. It supports Python 3.8, 3.9, 3.10, 3.11, and 3.12.</p>"},{"location":"community/faq/#can-i-install-depkeeper-globally","title":"Can I install depkeeper globally?","text":"<p>Yes, but we recommend using pipx for global installation to avoid polluting your system Python:</p> Bash<pre><code>pipx install depkeeper\n</code></pre>"},{"location":"community/faq/#does-depkeeper-work-on-windows","title":"Does depkeeper work on Windows?","text":"<p>Yes. depkeeper works on Windows, macOS, and Linux.</p>"},{"location":"community/faq/#usage","title":"Usage","text":""},{"location":"community/faq/#how-do-i-check-for-updates","title":"How do I check for updates?","text":"<p>Use the <code>check</code> command to scan your requirements file for available updates:</p> Bash<pre><code>depkeeper check\n</code></pre> <p>You can target a specific file and show only outdated packages:</p> Bash<pre><code>depkeeper check requirements.txt --outdated-only\n</code></pre>"},{"location":"community/faq/#how-do-i-update-dependencies","title":"How do I update dependencies?","text":"<p>Use the <code>update</code> command. Preview changes first with <code>--dry-run</code>, then apply:</p> Bash<pre><code>depkeeper update --dry-run\ndepkeeper update\n</code></pre>"},{"location":"community/faq/#can-i-update-specific-packages","title":"Can I update specific packages?","text":"<p>Yes. Use the <code>-p</code> flag to select individual packages:</p> Bash<pre><code>depkeeper update -p flask -p click\n</code></pre>"},{"location":"community/faq/#how-does-depkeeper-handle-major-version-boundaries","title":"How does depkeeper handle major version boundaries?","text":"<p>depkeeper never crosses major version boundaries when recommending updates. If your current version is <code>1.2.3</code>, depkeeper will recommend up to the latest <code>1.x.x</code> release, but will not suggest <code>2.0.0</code>. This protects you from breaking changes.</p>"},{"location":"community/faq/#what-output-formats-are-available","title":"What output formats are available?","text":"<p>The <code>check</code> command supports three output formats:</p> Format Flag Description Table <code>--format table</code> Rich formatted table (default) Simple <code>--format simple</code> Plain text output JSON <code>--format json</code> Machine-readable JSON"},{"location":"community/faq/#does-depkeeper-resolve-dependency-conflicts","title":"Does depkeeper resolve dependency conflicts?","text":"<p>Yes. When <code>--check-conflicts</code> is enabled (the default), depkeeper builds a dependency graph, detects version conflicts between packages, and iteratively adjusts recommendations until a conflict-free set is found.</p>"},{"location":"community/faq/#security","title":"Security","text":""},{"location":"community/faq/#is-it-safe-to-run-depkeeper-update","title":"Is it safe to run depkeeper update?","text":"<p>Yes. depkeeper never crosses major version boundaries, supports <code>--dry-run</code> to preview changes, and offers <code>--backup</code> to create timestamped backups before writing. For more details, see the Security Policy.</p>"},{"location":"community/faq/#configuration","title":"Configuration","text":""},{"location":"community/faq/#where-should-i-put-my-config-file","title":"Where should I put my config file?","text":"<p>You can pass a configuration file path directly with the <code>--config</code> flag or set the <code>DEPKEEPER_CONFIG</code> environment variable:</p> Bash<pre><code>depkeeper check --config path/to/config.toml\n</code></pre>"},{"location":"community/faq/#can-i-control-colored-output","title":"Can I control colored output?","text":"<p>Yes. Use <code>--no-color</code> to disable colored terminal output, or set the <code>DEPKEEPER_COLOR</code> environment variable:</p> Bash<pre><code>depkeeper check --no-color\n</code></pre>"},{"location":"community/faq/#what-verbosity-levels-are-available","title":"What verbosity levels are available?","text":"<p>Use <code>-v</code> for verbose output and <code>-vv</code> for maximum detail:</p> Bash<pre><code>depkeeper check -v\ndepkeeper check -vv\n</code></pre>"},{"location":"community/faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"community/faq/#why-am-i-getting-parsing-errors","title":"Why am I getting parsing errors?","text":"<p>Ensure your <code>requirements.txt</code> follows PEP 508 format. Common issues include:</p> <ul> <li>Invalid characters in package names</li> <li>Malformed version specifiers (e.g., missing operators)</li> <li>Incorrect URL syntax for VCS dependencies</li> </ul> <p>depkeeper supports all standard PEP 440/508 formats including extras, environment markers, include directives, constraint files, VCS URLs, editable installs, and hash verification.</p>"},{"location":"community/faq/#why-is-depkeeper-slow","title":"Why is depkeeper slow?","text":"<p>depkeeper uses concurrent async HTTP requests to query PyPI, so it is generally fast. If you experience slowness:</p> <ul> <li>Check your network connection</li> <li>Reduce request volume if you are being rate-limited by PyPI</li> <li>Consider using a private PyPI mirror for large dependency sets</li> </ul>"},{"location":"community/faq/#where-can-i-report-bugs","title":"Where can I report bugs?","text":"<p>Open an issue on GitHub. Include your OS, Python version, depkeeper version, and steps to reproduce the problem.</p>"},{"location":"community/faq/#contributing","title":"Contributing","text":""},{"location":"community/faq/#how-can-i-contribute","title":"How can I contribute?","text":"<p>See the Contributing Guide for setup instructions, testing, and pull request guidelines.</p>"},{"location":"community/license/","title":"License","text":"<p>This page covers the licensing terms for depkeeper and its third-party dependencies.</p>"},{"location":"community/license/#apache-license-20","title":"Apache License 2.0","text":"<p>depkeeper is released under the Apache License, Version 2.0.</p> Text Only<pre><code>Copyright 2025 Rahul Kaushal\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"community/license/#license-summary","title":"License Summary","text":"<p>The Apache License 2.0 is a permissive open source license that provides flexibility for both personal and commercial use.</p>"},{"location":"community/license/#permissions","title":"Permissions","text":"<ul> <li>Commercial Use -- Use depkeeper in commercial projects</li> <li>Modification -- Modify the source code as needed</li> <li>Distribution -- Share depkeeper with others</li> <li>Sublicensing -- Grant the same rights to others</li> <li>Private Use -- Use privately without sharing changes</li> <li>Patent Grant -- Express grant of patent rights from contributors</li> </ul>"},{"location":"community/license/#requirements","title":"Requirements","text":"<ul> <li>License and Copyright Notice -- Include the original license and copyright notice in copies or substantial portions of the software</li> <li>State Changes -- Document any modifications made to the code</li> </ul>"},{"location":"community/license/#limitations","title":"Limitations","text":"<ul> <li>Trademark Use -- Does not grant rights to use project trademarks or logos</li> <li>Liability -- Software is provided \"as is\" without warranty</li> <li>Warranty -- No warranty of any kind is provided</li> </ul>"},{"location":"community/license/#third-party-dependencies","title":"Third-Party Dependencies","text":"<p>depkeeper depends on the following open source libraries. All dependencies use permissive licenses compatible with Apache 2.0.</p> Library License Type click BSD-3-Clause Permissive httpx BSD-3-Clause Permissive rich MIT Permissive packaging Apache-2.0 / BSD-2-Clause Permissive"},{"location":"community/security/","title":"Security Policy","text":"<p>We take the security of depkeeper seriously. This page explains how to report vulnerabilities, what our response process looks like, and what security features depkeeper provides.</p>"},{"location":"community/security/#supported-versions","title":"Supported Versions","text":"<p>We provide security patches only for the latest release series.</p> Version Supported 0.1.x Yes &lt; 0.1 No <p>As depkeeper is in early development, we strongly recommend upgrading to the latest release at all times.</p>"},{"location":"community/security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>Do not create public GitHub issues for security vulnerabilities.</p> <p>To responsibly disclose a vulnerability, use one of the following private channels:</p> <ul> <li>The repository's Security tab -- Report a vulnerability</li> <li>A private GitHub Discussion with the maintainers</li> </ul> <p>We appreciate coordinated disclosure and will work with you to verify, fix, and publicly disclose issues responsibly.</p>"},{"location":"community/security/#what-to-include-in-your-report","title":"What to Include in Your Report","text":"<ol> <li>Description -- Clear explanation of the issue</li> <li>Impact -- What an attacker could achieve</li> <li>Affected Versions -- Specific versions you tested against</li> <li>Reproduction Steps -- Required for us to verify the issue</li> <li>Proof of Concept -- If available</li> <li>Potential Fix -- If you have thoughts or patches</li> </ol>"},{"location":"community/security/#response-timeline","title":"Response Timeline","text":"<p>After you submit a report, here is what to expect:</p> Timeframe Action 48 hours Initial acknowledgment 5 business days Validation decision Every 5-7 days Status updates Within 30 days Target resolution for critical vulnerabilities"},{"location":"community/security/#security-advisory-process","title":"Security Advisory Process","text":"<p>When a vulnerability is fixed, we will:</p> <ul> <li>Publish a GitHub Security Advisory</li> <li>Release a patched version</li> <li>Update the Changelog with a security entry</li> <li>Announce the fix through GitHub Releases</li> </ul> <p>Published advisories are available at github.com/rahulkaushal04/depkeeper/security/advisories.</p>"},{"location":"community/security/#scope","title":"Scope","text":""},{"location":"community/security/#in-scope","title":"In Scope","text":"<p>The following areas are within the scope of security reports:</p> <ul> <li>Parser, resolver, and updater logic</li> <li>Requirements file handling (malicious input)</li> <li>CLI command injection or unsafe shell execution</li> <li>Unsafe file operations or path traversal</li> <li>SSRF, MITM, or insecure HTTP behavior</li> <li>Authentication issues with private PyPI indices</li> <li>Dependency chain vulnerabilities affecting depkeeper itself</li> </ul>"},{"location":"community/security/#out-of-scope","title":"Out of Scope","text":"<p>The following are outside the scope of security reports:</p> <ul> <li>Vulnerabilities in third-party dependencies (report to those projects directly)</li> <li>Denial of service requiring extreme resources</li> <li>Social engineering attacks</li> <li>Physical access attacks</li> <li>Issues in unsupported versions</li> </ul>"},{"location":"community/security/#current-security-features","title":"Current Security Features","text":"<p>depkeeper includes the following security measures:</p> <ul> <li>HTTPS-only communication with PyPI</li> <li>SSL certificate verification</li> <li>Input validation and sanitization in the requirements parser</li> <li>Safe path handling to prevent directory traversal</li> <li>Atomic file writes with backup support</li> <li>Dry-run mode for previewing changes before applying</li> </ul>"},{"location":"community/security/#planned-security-features","title":"Planned Security Features","text":"<p>The following features are planned for future releases:</p> <ul> <li>Vulnerability scanning against known advisory databases</li> <li>Lock file generation with integrity verification</li> <li>Package signature verification</li> <li>SBOM (Software Bill of Materials) generation</li> </ul>"},{"location":"community/security/#best-practices-for-users","title":"Best Practices for Users","text":"<p>For safe day-to-day usage of depkeeper:</p> <ul> <li>Always use the latest version of depkeeper</li> <li>Only run depkeeper on trusted requirements files</li> <li>Preview changes with <code>--dry-run</code> before applying updates</li> <li>Use the <code>--backup</code> flag to create backups before updating</li> </ul>"},{"location":"community/security/#researcher-recognition","title":"Researcher Recognition","text":"<p>While depkeeper does not currently have a paid bug bounty program, we recognize security researchers by:</p> <ul> <li>Crediting reporters in security advisories</li> <li>Mentioning them in the changelog</li> <li>Adding them to contributor acknowledgments</li> </ul>"},{"location":"contributing/","title":"Contributing to depkeeper","text":"<p>We welcome contributions of all types, including bug fixes, new features, documentation improvements, and design suggestions. This project values clear communication, code quality, and respectful collaboration.</p>"},{"location":"contributing/#how-you-can-contribute","title":"How You Can Contribute","text":"<p>There are many ways to participate in the depkeeper project, regardless of your experience level.</p> Contribution Description Link Report a Bug Open an issue when you encounter unexpected behavior. Include clear reproduction steps. Open an issue Propose a Feature Submit feature requests or improvement ideas through discussions. Start a discussion Improve Documentation Keep documentation accurate, clear, and easy to follow. Edit documentation Contribute Code Fix bugs, improve performance, or add new features. Development setup"},{"location":"contributing/#contributor-resources","title":"Contributor Resources","text":"<p>Use these guides to get started:</p> <ul> <li>Development Setup -- Set up your local development environment</li> <li>Code Style Guide -- Follow coding standards and best practices</li> <li>Testing Guide -- Write and execute tests</li> <li>Release Process -- Understand how releases are planned and published</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributors must follow our Code of Conduct to maintain a respectful, inclusive, and professional environment.</p>"},{"location":"contributing/#getting-support","title":"Getting Support","text":"<p>Get help through the following channels:</p> <ul> <li>General Questions -- GitHub Discussions</li> <li>Bug Reports -- GitHub Issues</li> <li>Security Issues -- Security Policy</li> </ul>"},{"location":"contributing/#first-time-contributors","title":"First-Time Contributors","text":"<p>New to open-source contributions? Follow these steps:</p> <ol> <li>Find issues labeled <code>good first issue</code></li> <li>Review the Development Setup guide</li> <li>Follow the Code Style guidelines</li> <li>Submit a pull request</li> </ol> <p>Maintainers provide guidance during the review process.</p>"},{"location":"contributing/#standard-contribution-flow","title":"Standard Contribution Flow","text":"<ol> <li>Fork the repository</li> <li>Create a dedicated branch for your change</li> <li>Implement changes following project guidelines</li> <li>Add or update tests as required</li> <li>Open a pull request with a clear description</li> <li>Address review feedback</li> <li>Maintainers merge changes after approval</li> </ol>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<p>The depkeeper codebase is organized as follows:</p> Text Only<pre><code>depkeeper/\n\u251c\u2500\u2500 depkeeper/             # Source code\n\u2502   \u251c\u2500\u2500 commands/          # CLI command implementations (check, update)\n\u2502   \u251c\u2500\u2500 core/              # Dependency parsing, version checking, resolution\n\u2502   \u251c\u2500\u2500 models/            # Data models (package, requirement, conflict)\n\u2502   \u251c\u2500\u2500 utils/             # Console output, HTTP, logging, file I/O\n\u2502   \u251c\u2500\u2500 cli.py             # CLI entry point and global options\n\u2502   \u251c\u2500\u2500 constants.py       # Centralized configuration constants\n\u2502   \u251c\u2500\u2500 context.py         # CLI context management\n\u2502   \u2514\u2500\u2500 exceptions.py      # Custom exception hierarchy\n\u251c\u2500\u2500 tests/                 # Test suite (unit, integration, e2e)\n\u251c\u2500\u2500 docs/                  # Documentation source (MkDocs)\n\u2514\u2500\u2500 scripts/               # Development setup and automation\n</code></pre> <p>Thank you for contributing to depkeeper.</p>"},{"location":"contributing/code-style/","title":"Code Style","text":"<p>Coding standards and conventions for depkeeper. Following these guidelines ensures consistency, readability, and maintainability across the codebase.</p>"},{"location":"contributing/code-style/#guiding-principles","title":"Guiding Principles","text":"<ul> <li>Write clear, explicit, and predictable code</li> <li>Prefer readability over cleverness</li> <li>Follow established Python community standards</li> <li>Automate formatting and checks wherever possible</li> </ul>"},{"location":"contributing/code-style/#standards-overview","title":"Standards Overview","text":"<p>depkeeper follows modern Python best practices:</p> Area Tool / Standard Style Guide PEP 8 Formatting Black Type Checking mypy (strict mode) Automation pre-commit Python Version 3.8+"},{"location":"contributing/code-style/#automated-tooling","title":"Automated Tooling","text":""},{"location":"contributing/code-style/#code-formatting-black","title":"Code Formatting (Black)","text":"<p>Black enforces consistent, opinionated code formatting.</p> Bash<pre><code># Format all files\nblack .\n\n# Check formatting without modifying files\nblack --check .\n</code></pre>"},{"location":"contributing/code-style/#static-type-checking-mypy","title":"Static Type Checking (mypy)","text":"<p>mypy runs in strict mode to enforce strong typing.</p> Bash<pre><code>mypy depkeeper\n</code></pre> <p>All new code must be fully type-annotated and pass mypy without errors.</p>"},{"location":"contributing/code-style/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Formatting and checks run automatically before commits.</p> Bash<pre><code># Install hooks\npre-commit install\n\n# Run manually\npre-commit run --all-files\n</code></pre>"},{"location":"contributing/code-style/#python-style-guidelines","title":"Python Style Guidelines","text":""},{"location":"contributing/code-style/#imports","title":"Imports","text":"Python<pre><code>from __future__ import annotations\n\n# Standard library\nimport asyncio\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Third-party\nimport click\nfrom packaging.version import Version\n\n# Local\nfrom depkeeper.models import Package\nfrom depkeeper.utils.logger import get_logger\n</code></pre> <p>Import rules:</p> <ul> <li>Use <code>from __future__ import annotations</code></li> <li>Group imports: standard library, third-party, local</li> <li>Use absolute imports</li> <li>Avoid wildcard imports</li> </ul>"},{"location":"contributing/code-style/#type-annotations-python-38","title":"Type Annotations (Python 3.8)","text":"<p>All new code must use Python 3.8-compatible typing.</p> Python<pre><code>from typing import Optional\n\ndef get_package(\n    name: str,\n    version: Optional[str] = None,\n) -&gt; Package:\n    ...\n</code></pre> <p>Collections:</p> Python<pre><code>from typing import Dict, List\n\ndef process_items(items: List[str]) -&gt; Dict[str, int]:\n    ...\n</code></pre> <p>Union types:</p> Python<pre><code>from typing import Union\n\ndef normalize(value: Union[str, int]) -&gt; str:\n    ...\n</code></pre> <p>Structured data:</p> Python<pre><code>from typing import TypedDict\n\nclass PackageInfo(TypedDict):\n    name: str\n    version: str\n    dependencies: List[str]\n</code></pre>"},{"location":"contributing/code-style/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings for all public modules, classes, and functions.</p> Python<pre><code>def check_package(name: str) -&gt; Package:\n    \"\"\"Check a package for available updates.\n\n    Args:\n        name: Package name.\n\n    Returns:\n        Package with version recommendations.\n\n    Raises:\n        PyPIError: If package metadata cannot be retrieved.\n    \"\"\"\n</code></pre>"},{"location":"contributing/code-style/#classes-and-data-models","title":"Classes and Data Models","text":"<p>Use <code>@dataclass</code> for data-centric classes.</p> Python<pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Package:\n    \"\"\"Represents a Python package.\"\"\"\n\n    name: str\n    current_version: Optional[str] = None\n    recommended_version: Optional[str] = None\n\n    def __post_init__(self) -&gt; None:\n        self.name = self.name.lower().replace(\"_\", \"-\")\n</code></pre>"},{"location":"contributing/code-style/#asynchronous-code","title":"Asynchronous Code","text":"<p>Use async APIs for I/O-bound operations.</p> Python<pre><code>async def fetch_package(name: str) -&gt; Dict[str, str]:\n    async with HTTPClient() as client:\n        return await client.get(name)\n</code></pre> <p>For concurrency:</p> Python<pre><code>results = await asyncio.gather(*tasks, return_exceptions=True)\n</code></pre>"},{"location":"contributing/code-style/#error-handling","title":"Error Handling","text":"<p>Follow these practices for exception handling:</p> <ul> <li>Use custom exception types</li> <li>Never suppress exceptions</li> <li>Preserve original traceback context</li> </ul> Python<pre><code>from depkeeper.exceptions import ParseError\n\ntry:\n    parse_line(line)\nexcept ValueError as exc:\n    raise ParseError(f\"Invalid requirement: {line}\") from exc\n</code></pre>"},{"location":"contributing/code-style/#constants","title":"Constants","text":"<p>Define all constants in <code>constants.py</code>.</p> Python<pre><code>DEFAULT_TIMEOUT = 30\nMAX_RETRIES = 3\n</code></pre> <p>Avoid using inline magic values.</p>"},{"location":"contributing/code-style/#naming-conventions","title":"Naming Conventions","text":"Element Convention Example Module snake_case <code>version_checker.py</code> Class PascalCase <code>VersionChecker</code> Function snake_case <code>check_package()</code> Variable snake_case <code>current_version</code> Constant UPPER_SNAKE <code>MAX_RETRIES</code> Private <code>_leading_underscore</code> <code>_parse()</code>"},{"location":"contributing/code-style/#code-organization","title":"Code Organization","text":"<p>Recommended module layout:</p> Python<pre><code>\"\"\"Module description.\"\"\"\n\nfrom __future__ import annotations\n\n# Imports\n...\n\nlogger = get_logger(__name__)\n\n__all__ = [\"PublicClass\"]\n\nclass PublicClass:\n    ...\n\ndef public_function() -&gt; None:\n    ...\n\ndef _private_helper() -&gt; None:\n    ...\n</code></pre>"},{"location":"contributing/code-style/#function-design","title":"Function Design","text":"<p>Follow these guidelines for writing functions:</p> <ul> <li>Keep functions under 50 lines when possible</li> <li>Limit each function to one responsibility</li> <li>Extract complex logic into helper functions</li> <li>Prefer explicit flow over implicit behavior</li> </ul>"},{"location":"contributing/code-style/#cli-code-style","title":"CLI Code Style","text":"<p>Click-based commands should remain explicit and readable.</p> Python<pre><code>@click.command()\n@click.argument(\"file\", type=Path)\n@click.option(\"--dry-run\", is_flag=True)\ndef check(file: Path, dry_run: bool) -&gt; None:\n    \"\"\"Check dependencies for updates.\"\"\"\n</code></pre>"},{"location":"contributing/code-style/#testing-style","title":"Testing Style","text":"<p>Refer to Testing for complete testing guidelines.</p> Python<pre><code>def test_parser_handles_extras():\n    ...\n</code></pre> <p>Follow these practices:</p> <ul> <li>Use clear, descriptive test names</li> <li>Create reusable fixtures</li> <li>Parametrize tests for variations</li> </ul>"},{"location":"contributing/code-style/#logging","title":"Logging","text":"<p>Use structured logging with appropriate severity.</p> Python<pre><code>logger.debug(\"Fetching metadata for %s\", name)\nlogger.info(\"Processed %d packages\", count)\nlogger.warning(\"Using fallback version\")\nlogger.error(\"Failed to parse input\")\n</code></pre>"},{"location":"contributing/code-style/#anti-patterns","title":"Anti-Patterns","text":"<p>Avoid these patterns:</p> Python<pre><code>def func(items=[]):  # Mutable default\n    ...\n\nexcept:  # Bare except\n    ...\n\nfrom module import *  # Wildcard import\n</code></pre> <p>Preferred alternatives:</p> Python<pre><code>from typing import Optional, List\n\ndef func(items: Optional[List[str]] = None):\n    items = items or []\n\nexcept ValueError as exc:\n    ...\n\nfrom module import specific_function\n</code></pre>"},{"location":"contributing/code-style/#next-steps","title":"Next Steps","text":"<ul> <li>Testing -- Learn testing practices and guidelines</li> <li>Development Setup -- Set up your development environment</li> </ul>"},{"location":"contributing/development-setup/","title":"Development Setup","text":"<p>Set up a local development environment for contributing to depkeeper. This guide covers prerequisites, installation, workflows, and tooling configuration.</p>"},{"location":"contributing/development-setup/#prerequisites","title":"Prerequisites","text":"<p>Install the following tools:</p> <ul> <li>Python \u2265 3.8</li> <li>Git for version control</li> <li>Make (optional) for development shortcuts</li> </ul> <p>Verify your Python version:</p> Bash<pre><code>python --version\n</code></pre>"},{"location":"contributing/development-setup/#installation","title":"Installation","text":"<p>Choose between automated setup scripts or manual installation steps.</p>"},{"location":"contributing/development-setup/#option-1-automated-setup-recommended","title":"Option 1: Automated Setup (Recommended)","text":""},{"location":"contributing/development-setup/#macos-linux","title":"macOS / Linux","text":"Bash<pre><code>git clone https://github.com/rahulkaushal04/depkeeper.git\ncd depkeeper\nbash scripts/setup_dev.sh\n</code></pre>"},{"location":"contributing/development-setup/#windows-powershell","title":"Windows (PowerShell)","text":"PowerShell<pre><code>git clone https://github.com/rahulkaushal04/depkeeper.git\ncd depkeeper\n.\\scripts\\setup_dev.ps1\n</code></pre> <p>These scripts create a virtual environment, install dependencies, and configure development tools.</p>"},{"location":"contributing/development-setup/#option-2-manual-setup","title":"Option 2: Manual Setup","text":"<p>Manual setup provides full control over each installation step.</p> Bash<pre><code># Clone repository\ngit clone https://github.com/rahulkaushal04/depkeeper.git\ncd depkeeper\n\n# Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# macOS / Linux\nsource venv/bin/activate\n\n# Windows\nvenv\\Scripts\\activate\n\n# Install dependencies in editable mode\npip install -e \".[dev]\"\n\n# Install pre-commit hooks\npre-commit install\n</code></pre>"},{"location":"contributing/development-setup/#verify-installation","title":"Verify Installation","text":"<p>Confirm the installation succeeded:</p> Bash<pre><code># Verify CLI\npython -m depkeeper --version\n\n# Run test suite\npytest\n\n# Run all linters and checks\npre-commit run --all-files\n</code></pre> <p>Each command should complete without errors.</p>"},{"location":"contributing/development-setup/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/development-setup/#1-create-a-branch","title":"1. Create a Branch","text":"<p>Use descriptive branch names with appropriate prefixes:</p> Change Type Prefix Example Feature <code>feature/</code> <code>feature/add-lock-file</code> Bug fix <code>fix/</code> <code>fix/parse-error-handling</code> Documentation <code>docs/</code> <code>docs/update-installation</code> Refactor <code>refactor/</code> <code>refactor/simplify-parser</code> Tests <code>test/</code> <code>test/add-integration-tests</code> Bash<pre><code>git checkout -b feature/my-feature\n</code></pre>"},{"location":"contributing/development-setup/#2-implement-changes","title":"2. Implement Changes","text":"<ul> <li>Follow the project\u2019s Code Style</li> <li>Keep changes focused and minimal</li> <li>Add or update tests where applicable</li> </ul>"},{"location":"contributing/development-setup/#3-run-tests","title":"3. Run Tests","text":"<p>Run the test suite to verify your changes:</p> Bash<pre><code># Full test suite\npytest\n\n# With coverage\npytest --cov=depkeeper\n\n# Specific test file\npytest tests/unit/test_parser.py\n\n# Tests matching a pattern\npytest -k \"test_parse\"\n</code></pre>"},{"location":"contributing/development-setup/#4-run-linters-and-type-checks","title":"4. Run Linters and Type Checks","text":"<p>Ensure code quality standards are met:</p> Bash<pre><code># Run all checks\npre-commit run --all-files\n\n# Individual tools\nblack .\nmypy depkeeper\n</code></pre> <p>All checks must pass before opening a pull request.</p>"},{"location":"contributing/development-setup/#5-commit-changes","title":"5. Commit Changes","text":"<p>Write clear, meaningful commit messages:</p> Bash<pre><code>git add .\ngit commit -m \"feat: add lock file generation\n\n- Implement lock file writer\n- Add hash verification\n- Update documentation\"\n</code></pre> <p>The project follows Conventional Commits:</p> Prefix Purpose <code>feat:</code> New feature <code>fix:</code> Bug fix <code>docs:</code> Documentation <code>style:</code> Formatting only <code>refactor:</code> Internal refactoring <code>test:</code> Tests <code>chore:</code> Maintenance tasks"},{"location":"contributing/development-setup/#6-push-and-open-a-pull-request","title":"6. Push and Open a Pull Request","text":"<p>Push your branch and create a pull request:</p> Bash<pre><code>git push origin feature/my-feature\n</code></pre> <p>Include in your pull request:</p> <ul> <li>Clear description of changes</li> <li>References to related issues</li> <li>Test results or validation notes</li> </ul>"},{"location":"contributing/development-setup/#makefile-shortcuts","title":"Makefile Shortcuts","text":"<p>Use these shortcuts for common development tasks:</p> Bash<pre><code>make install       # Install depkeeper in production mode\nmake install-dev   # Install with dev dependencies and pre-commit hooks\nmake test          # Run tests with coverage reports\nmake typecheck     # Run mypy static type checks\nmake all           # Run typecheck and test together\nmake clean         # Remove cache and build artifacts\nmake docs          # Build documentation\nmake docs-serve    # Serve documentation locally\n</code></pre>"},{"location":"contributing/development-setup/#environment-variables","title":"Environment Variables","text":"<p>Configure these variables for development:</p> Bash<pre><code># Path to configuration file\nexport DEPKEEPER_CONFIG=path/to/config.toml\n\n# Disable colored output\nexport DEPKEEPER_COLOR=false\n</code></pre> <p>For debug-level logging, use the <code>-vv</code> flag when running commands:</p> Bash<pre><code>depkeeper -vv check\n</code></pre>"},{"location":"contributing/development-setup/#ide-configuration","title":"IDE Configuration","text":""},{"location":"contributing/development-setup/#vs-code","title":"VS Code","text":"<p>Install these recommended extensions:</p> <ul> <li>Python</li> <li>Pylance</li> <li>Black Formatter</li> <li>Even Better TOML</li> </ul> <p>Add this configuration to <code>.vscode/settings.json</code>:</p> JSON<pre><code>{\n  \"python.defaultInterpreterPath\": \"${workspaceFolder}/venv/bin/python\",\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestArgs\": [\"tests\"],\n  \"[python]\": {\n    \"editor.formatOnSave\": true,\n    \"editor.defaultFormatter\": \"ms-python.black-formatter\"\n  }\n}\n</code></pre>"},{"location":"contributing/development-setup/#pycharm","title":"PyCharm","text":"<p>Configure your PyCharm environment:</p> <ol> <li>Set project interpreter to <code>./venv/bin/python</code></li> <li>Mark <code>depkeeper</code> as Sources Root</li> <li>Mark <code>tests</code> as Test Sources Root</li> <li>Configure pytest as the test runner</li> </ol>"},{"location":"contributing/development-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"contributing/development-setup/#virtual-environment-issues","title":"Virtual Environment Issues","text":"<p>Recreate the virtual environment:</p> Bash<pre><code>rm -rf venv\npython -m venv venv\nsource venv/bin/activate\npip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/development-setup/#import-errors","title":"Import Errors","text":"<p>Verify the virtual environment is active:</p> Bash<pre><code>which python\n# Expected: path/to/depkeeper/venv/bin/python\n</code></pre>"},{"location":"contributing/development-setup/#pre-commit-failures","title":"Pre-commit Failures","text":"<p>Update hooks or run them individually:</p> Bash<pre><code># Update hooks\npre-commit autoupdate\n\n# Run a specific hook\npre-commit run black --all-files\n</code></pre>"},{"location":"contributing/development-setup/#next-steps","title":"Next Steps","text":"<ul> <li>Code Style -- Learn coding standards and formatting requirements</li> <li>Testing -- Understand testing practices and guidelines</li> <li>Release Process -- Review versioning and release procedures</li> </ul>"},{"location":"contributing/release-process/","title":"Release Process","text":"<p>How depkeeper releases are created and published.</p>"},{"location":"contributing/release-process/#overview","title":"Overview","text":"<p>depkeeper follows Semantic Versioning:</p> <ul> <li>MAJOR: Breaking changes</li> <li>MINOR: New features (backward compatible)</li> <li>PATCH: Bug fixes (backward compatible)</li> </ul>"},{"location":"contributing/release-process/#version-numbering","title":"Version Numbering","text":""},{"location":"contributing/release-process/#current-version","title":"Current Version","text":"<p>The version is defined in <code>depkeeper/__version__.py</code>:</p> Python<pre><code>__version__ = \"0.1.0\"\n</code></pre>"},{"location":"contributing/release-process/#version-format","title":"Version Format","text":"Component Required Description MAJOR Yes Breaking changes MINOR Yes New features (backward compatible) PATCH Yes Bug fixes (backward compatible) PRERELEASE Optional Alpha, beta, or release candidate (e.g., <code>-alpha.1</code>, <code>-rc.1</code>) BUILD Optional Build metadata (e.g., <code>+20260209</code>) <p>Examples:</p> <ul> <li><code>0.1.0</code> - Initial development release</li> <li><code>1.0.0</code> - First stable release</li> <li><code>1.2.3</code> - Stable release</li> <li><code>2.0.0-alpha.1</code> - Pre-release</li> <li><code>2.0.0-rc.1</code> - Release candidate</li> </ul>"},{"location":"contributing/release-process/#release-checklist","title":"Release Checklist","text":""},{"location":"contributing/release-process/#1-prepare-the-release","title":"1. Prepare the Release","text":"<p>Verify these requirements:</p> <ul> <li> All tests passing on main branch</li> <li> Documentation updated</li> <li> CHANGELOG.md updated</li> <li> Version number bumped</li> </ul>"},{"location":"contributing/release-process/#2-update-version","title":"2. Update Version","text":"<p>Edit <code>depkeeper/__version__.py</code>:</p> Python<pre><code>__version__ = \"0.2.0\"  # New version\n</code></pre>"},{"location":"contributing/release-process/#3-update-changelog","title":"3. Update CHANGELOG","text":"<p>Add a new section to <code>CHANGELOG.md</code>:</p> Markdown<pre><code>## [0.2.0] - 2026-02-08\n\n### Added\n- New feature X\n- Support for Y\n\n### Changed\n- Improved Z performance\n\n### Fixed\n- Bug in parser (#123)\n\n### Security\n- Updated httpx to fix CVE-XXXX\n</code></pre>"},{"location":"contributing/release-process/#4-create-release-commit","title":"4. Create Release Commit","text":"<p>Commit the version changes:</p> Bash<pre><code>git add depkeeper/__version__.py CHANGELOG.md\ngit commit -m \"release: v0.2.0\"\n</code></pre>"},{"location":"contributing/release-process/#5-tag-the-release","title":"5. Tag the Release","text":"<p>Create and push the version tag:</p> Bash<pre><code>git tag -a v0.2.0 -m \"Release v0.2.0\"\ngit push origin main --tags\n</code></pre>"},{"location":"contributing/release-process/#6-build-and-publish","title":"6. Build and Publish","text":"<p>Build and upload to PyPI:</p> Bash<pre><code># Clean previous builds\nrm -rf dist/\n\n# Build\npython -m build\n\n# Upload to PyPI\npython -m twine upload dist/*\n</code></pre>"},{"location":"contributing/release-process/#7-create-github-release","title":"7. Create GitHub Release","text":"<p>Publish the release on GitHub:</p> <ol> <li>Go to Releases</li> <li>Click \"Draft a new release\"</li> <li>Select the tag</li> <li>Copy changelog entries to description</li> <li>Attach built distributions</li> <li>Publish release</li> </ol>"},{"location":"contributing/release-process/#changelog-format","title":"CHANGELOG Format","text":"<p>Follow the Keep a Changelog format:</p> Markdown<pre><code># Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n### Added\n- Feature in development\n\n## [0.2.0] - 2026-02-08\n\n### Added\n- Lock file generation\n- Health scoring\n\n### Changed\n- Improved dependency resolution\n\n### Fixed\n- Parser edge case (#123)\n\n## [0.1.0] - 2026-01-15\n\n### Added\n- Initial release\n- Check command\n- Update command\n</code></pre>"},{"location":"contributing/release-process/#change-categories","title":"Change Categories","text":"Category Description Added New features Changed Changes in existing functionality Deprecated Soon-to-be removed features Removed Removed features Fixed Bug fixes Security Security fixes"},{"location":"contributing/release-process/#hotfix-process","title":"Hotfix Process","text":"<p>Apply urgent fixes to released versions:</p> <ol> <li> <p>Create hotfix branch from tag:    Bash<pre><code>git checkout -b hotfix/0.1.1 v0.1.0\n</code></pre></p> </li> <li> <p>Apply fix and commit</p> </li> <li> <p>Bump patch version:    Python<pre><code>__version__ = \"0.1.1\"\n</code></pre></p> </li> <li> <p>Update CHANGELOG</p> </li> <li> <p>Tag and release:    Bash<pre><code>git tag -a v0.1.1 -m \"Hotfix v0.1.1\"\ngit push origin v0.1.1\n</code></pre></p> </li> <li> <p>Merge back to main:    Bash<pre><code>git checkout main\ngit merge hotfix/0.1.1\n</code></pre></p> </li> </ol>"},{"location":"contributing/release-process/#pypi-publishing","title":"PyPI Publishing","text":""},{"location":"contributing/release-process/#manual-publishing","title":"Manual Publishing","text":"Bash<pre><code># Build\npython -m build\n\n# Check package\ntwine check dist/*\n\n# Upload to TestPyPI first\ntwine upload --repository testpypi dist/*\n\n# Test installation\npip install --index-url https://test.pypi.org/simple/ depkeeper\n\n# Upload to PyPI\ntwine upload dist/*\n</code></pre>"},{"location":"contributing/release-process/#pypi-token","title":"PyPI Token","text":"<p>Store your PyPI token securely as GitHub secret <code>PYPI_TOKEN</code>.</p> <p>Generate tokens at: https://pypi.org/manage/account/token/</p>"},{"location":"contributing/release-process/#post-release","title":"Post-Release","text":"<p>Complete these tasks after releasing:</p> <ol> <li>Announce - Post on social media and mailing lists</li> <li>Monitor - Watch for issue reports</li> <li>Document - Update any outdated documentation</li> <li>Plan - Start planning the next release</li> </ol>"},{"location":"contributing/release-process/#emergency-rollback","title":"Emergency Rollback","text":"<p>Handle critical issues in releases:</p> <ol> <li> <p>Yank from PyPI - Hide the problematic release:    Bash<pre><code>pip install twine\ntwine upload --skip-existing dist/*\n# Use PyPI web interface to yank\n</code></pre></p> </li> <li> <p>Notify users - Update GitHub release notes</p> </li> <li> <p>Fix and re-release - Follow hotfix process</p> </li> </ol>"},{"location":"contributing/release-process/#see-also","title":"See Also","text":"<ul> <li>Development Setup -- Set up your development environment</li> <li>Testing -- Learn testing guidelines</li> <li>Code Style -- Follow coding standards</li> </ul>"},{"location":"contributing/testing/","title":"Testing","text":"<p>Comprehensive testing guidelines for depkeeper contributors. This guide covers running tests locally, writing test cases, and maintaining code quality.</p> <p>Goals of the Test Suite</p> <ul> <li>Correctness - Ensure features work as intended</li> <li>Regression Prevention - Catch bugs before they ship</li> <li>Safe Refactoring - Confidently improve code structure</li> <li>Documentation - Tests serve as executable specifications</li> </ul>"},{"location":"contributing/testing/#quick-start","title":"Quick Start","text":"Basic CommandsTargeted TestingDevelopment Mode Bash<pre><code># Run all tests\npytest\n\n# Run with verbose output\npytest -v\n\n# Run with coverage report\npytest --cov=depkeeper --cov-report=html\n</code></pre> Bash<pre><code># Run specific test file\npytest tests/unit/test_parser.py\n\n# Run specific test function\npytest tests/unit/test_parser.py::test_parse_simple_requirement\n\n# Run tests matching a pattern\npytest -k \"parser\"\n\n# Run tests by marker\npytest -m \"unit\"\n</code></pre> Bash<pre><code># Stop on first failure\npytest -x\n\n# Show local variables on failure\npytest -l\n\n# Run failed tests first\npytest --ff\n\n# Watch mode (requires pytest-watch)\nptw -- -x\n</code></pre>"},{"location":"contributing/testing/#test-organization","title":"Test Organization","text":"<p>The test suite is organized by scope and responsibility:</p> Text Only<pre><code>tests/\n\u251c\u2500\u2500 conftest.py           # Shared fixtures and pytest configuration\n\u251c\u2500\u2500 fixtures/             # Test data files\n\u2502   \u251c\u2500\u2500 requirements/     # Sample requirements.txt files\n\u2502   \u2514\u2500\u2500 responses/        # Mock API response data\n\u251c\u2500\u2500 unit/                 # Unit tests (fast, isolated)\n\u2502   \u251c\u2500\u2500 core/             # Core module tests\n\u2502   \u251c\u2500\u2500 models/           # Data model tests\n\u2502   \u2514\u2500\u2500 utils/            # Utility function tests\n\u251c\u2500\u2500 integration/          # Integration tests (component interaction)\n\u2514\u2500\u2500 e2e/                  # End-to-end tests (CLI workflows)\n</code></pre>"},{"location":"contributing/testing/#test-categories","title":"Test Categories","text":"Category Scope Speed Dependencies Unit Single function/class Fast (&lt;1ms) Fully mocked Integration Multiple components Medium (&lt;1s) Partially mocked End-to-End Full CLI workflow Slow (&lt;10s) Minimal mocking <p>Test Distribution Rule</p> <p>Follow the testing pyramid: approximately 70% unit, 20% integration, 10% end-to-end tests.</p>"},{"location":"contributing/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"contributing/testing/#anatomy-of-a-good-test","title":"Anatomy of a Good Test","text":"<p>Every test should follow the Arrange-Act-Assert pattern:</p> tests/unit/core/test_parser.py<pre><code>from depkeeper.core.parser import RequirementsParser\n\n\ndef test_parse_simple_requirement():\n    \"\"\"Parser correctly handles a pinned version.\"\"\"\n    # Arrange: Set up test data and dependencies\n    parser = RequirementsParser()\n\n    # Act: Execute the code under test\n    result = parser.parse_line(\"requests==2.28.0\", line_number=1)\n\n    # Assert: Verify the expected outcome\n    assert result.name == \"requests\"\n    assert result.specs == [(\"==\", \"2.28.0\")]\n</code></pre> <p>Test Naming Convention</p> <p>Use descriptive names: <code>test_&lt;what&gt;_&lt;condition&gt;_&lt;expected&gt;</code>. For example:</p> <ul> <li><code>test_parse_line_with_extras_returns_extras_list</code></li> <li><code>test_checker_network_timeout_raises_timeout_error</code></li> </ul>"},{"location":"contributing/testing/#using-fixtures","title":"Using Fixtures","text":"<p>Fixtures provide reusable test setup. Define them in <code>conftest.py</code>:</p> conftest.pyUsing Fixtures tests/conftest.py<pre><code>import pytest\nfrom pathlib import Path\nfrom depkeeper.core.parser import RequirementsParser\n\n\n@pytest.fixture\ndef parser() -&gt; RequirementsParser:\n    \"\"\"Provide a fresh parser instance.\"\"\"\n    return RequirementsParser()\n\n\n@pytest.fixture\ndef sample_requirements_file(tmp_path: Path) -&gt; Path:\n    \"\"\"Create a temporary requirements file with common packages.\"\"\"\n    content = \"\"\"\\\n# Production dependencies\nrequests&gt;=2.28.0\nflask==2.3.0\nclick&gt;=8.0.0\n\n# Development tools\npytest&gt;=7.0.0\n\"\"\"\n    file_path = tmp_path / \"requirements.txt\"\n    file_path.write_text(content)\n    return file_path\n\n\n@pytest.fixture\ndef complex_requirements_file(tmp_path: Path) -&gt; Path:\n    \"\"\"Create a requirements file with advanced syntax.\"\"\"\n    content = \"\"\"\\\nrequests[security,socks]&gt;=2.28.0,&lt;3.0\nDjango&gt;=4.0; python_version &gt;= '3.10'\n-e git+https://github.com/user/repo.git@main#egg=package\n./local-package\n\"\"\"\n    file_path = tmp_path / \"requirements.txt\"\n    file_path.write_text(content)\n    return file_path\n</code></pre> tests/unit/core/test_parser.py<pre><code>def test_parse_file_counts_packages(parser, sample_requirements_file):\n    \"\"\"Parser extracts all package requirements from file.\"\"\"\n    requirements = parser.parse_file(sample_requirements_file)\n\n    # Should find 4 packages (comments excluded)\n    assert len(requirements) == 4\n    assert requirements[0].name == \"requests\"\n\n\ndef test_parse_complex_syntax(parser, complex_requirements_file):\n    \"\"\"Parser handles advanced requirement syntax.\"\"\"\n    requirements = parser.parse_file(complex_requirements_file)\n\n    # Check extras are parsed\n    assert \"security\" in requirements[0].extras\n    assert \"socks\" in requirements[0].extras\n\n    # Check environment markers\n    assert requirements[1].markers is not None\n</code></pre>"},{"location":"contributing/testing/#fixture-scopes","title":"Fixture Scopes","text":"<p>Choose the right scope to balance isolation and performance:</p> tests/conftest.py<pre><code>import pytest\n\n\n@pytest.fixture(scope=\"function\")  # Default: fresh for each test\ndef parser():\n    return RequirementsParser()\n\n\n@pytest.fixture(scope=\"module\")  # Shared within a test file\ndef mock_pypi_responses():\n    return load_json_fixtures(\"responses/pypi/\")\n\n\n@pytest.fixture(scope=\"session\")  # Shared across entire test run\ndef docker_services():\n    # Expensive setup like containers\n    yield start_services()\n    cleanup_services()\n</code></pre> <p>Fixture Scope Gotchas</p> <ul> <li>Avoid mutating module or session scoped fixtures</li> <li>Use function scope when tests modify fixture state</li> <li>Session-scoped fixtures must be thread-safe for parallel tests</li> </ul>"},{"location":"contributing/testing/#async-testing","title":"Async Testing","text":"<p>depkeeper uses async I/O for network operations. Test async code with pytest-asyncio:</p> tests/unit/core/test_checker.py<pre><code>import pytest\n\n\n@pytest.mark.asyncio\nasync def test_fetch_package_info():\n    \"\"\"VersionChecker retrieves package data from PyPI.\"\"\"\n    from depkeeper.core import PyPIDataStore, VersionChecker\n    from depkeeper.utils import HTTPClient\n\n    async with HTTPClient() as http:\n        store = PyPIDataStore(http)\n        checker = VersionChecker(data_store=store)\n\n        pkg = await checker.get_package_info(\"requests\")\n\n        assert pkg.name == \"requests\"\n        assert pkg.latest_version is not None\n</code></pre>"},{"location":"contributing/testing/#async-fixtures","title":"Async Fixtures","text":"tests/conftest.py<pre><code>import pytest\nimport pytest_asyncio\n\n\n@pytest_asyncio.fixture\nasync def http_client():\n    \"\"\"Provide an async HTTP client with automatic cleanup.\"\"\"\n    from depkeeper.utils import HTTPClient\n\n    async with HTTPClient() as client:\n        yield client\n\n\n@pytest_asyncio.fixture\nasync def checker(http_client):\n    \"\"\"Provide a configured VersionChecker.\"\"\"\n    from depkeeper.core import PyPIDataStore, VersionChecker\n\n    store = PyPIDataStore(http_client)\n    return VersionChecker(data_store=store)\n</code></pre>"},{"location":"contributing/testing/#mocking-external-services","title":"Mocking External Services","text":"<p>Golden Rule</p> <p>Never make real network calls in tests. All external services must be mocked.</p>"},{"location":"contributing/testing/#mocking-http-requests","title":"Mocking HTTP Requests","text":"<p>Use pytest-httpx to mock HTTP responses:</p> Basic MockMultiple RequestsError Responses tests/unit/core/test_checker.py<pre><code>import pytest\n\n\n@pytest.mark.asyncio\nasync def test_checker_returns_latest_version(httpx_mock):\n    \"\"\"VersionChecker identifies the latest available version.\"\"\"\n    # Arrange: Mock PyPI response\n    httpx_mock.add_response(\n        url=\"https://pypi.org/pypi/requests/json\",\n        json={\n            \"info\": {\"name\": \"requests\", \"version\": \"2.31.0\"},\n            \"releases\": {\n                \"2.28.0\": [{\"upload_time\": \"2023-01-01\"}],\n                \"2.31.0\": [{\"upload_time\": \"2023-06-15\"}],\n            },\n        },\n    )\n\n    # Act\n    from depkeeper.core import PyPIDataStore, VersionChecker\n    from depkeeper.utils import HTTPClient\n\n    async with HTTPClient() as http:\n        store = PyPIDataStore(http)\n        checker = VersionChecker(data_store=store)\n        pkg = await checker.get_package_info(\"requests\", \"2.28.0\")\n\n    # Assert\n    assert pkg.latest_version == \"2.31.0\"\n    assert pkg.current_version == \"2.28.0\"\n    assert pkg.update_available is True\n</code></pre> tests/integration/test_batch_check.py<pre><code>import pytest\n\n\n@pytest.mark.asyncio\nasync def test_batch_check_multiple_packages(httpx_mock):\n    \"\"\"Checker efficiently handles multiple package queries.\"\"\"\n    # Mock responses for multiple packages\n    packages = [\"requests\", \"flask\", \"click\"]\n    for pkg in packages:\n        httpx_mock.add_response(\n            url=f\"https://pypi.org/pypi/{pkg}/json\",\n            json={\n                \"info\": {\"name\": pkg, \"version\": \"1.0.0\"},\n                \"releases\": {\"1.0.0\": [{}]},\n            },\n        )\n\n    # ... test implementation\n</code></pre> tests/unit/core/test_checker_errors.py<pre><code>import pytest\nimport httpx\n\n\n@pytest.mark.asyncio\nasync def test_checker_handles_not_found(httpx_mock):\n    \"\"\"VersionChecker gracefully handles missing packages.\"\"\"\n    httpx_mock.add_response(\n        url=\"https://pypi.org/pypi/nonexistent-pkg/json\",\n        status_code=404,\n    )\n\n    from depkeeper.core import PyPIDataStore, VersionChecker\n    from depkeeper.utils import HTTPClient\n    from depkeeper.exceptions import PackageNotFoundError\n\n    async with HTTPClient() as http:\n        store = PyPIDataStore(http)\n        checker = VersionChecker(data_store=store)\n\n        with pytest.raises(PackageNotFoundError) as exc:\n            await checker.get_package_info(\"nonexistent-pkg\")\n\n        assert \"nonexistent-pkg\" in str(exc.value)\n\n\n@pytest.mark.asyncio\nasync def test_checker_handles_timeout(httpx_mock):\n    \"\"\"VersionChecker handles network timeouts gracefully.\"\"\"\n    httpx_mock.add_exception(\n        httpx.TimeoutException(\"Connection timed out\")\n    )\n\n    # ... test implementation\n</code></pre>"},{"location":"contributing/testing/#using-mock-fixtures","title":"Using Mock Fixtures","text":"<p>For complex mock setups, create reusable fixtures:</p> tests/conftest.py<pre><code>import pytest\nimport json\nfrom pathlib import Path\nfrom typing import List, Optional\n\n\n@pytest.fixture\ndef mock_pypi_package(httpx_mock):\n    \"\"\"Factory fixture to mock PyPI package responses.\"\"\"\n\n    def _mock(name: str, versions: List[str], latest: Optional[str] = None):\n        latest = latest or versions[-1]\n        httpx_mock.add_response(\n            url=f\"https://pypi.org/pypi/{name}/json\",\n            json={\n                \"info\": {\"name\": name, \"version\": latest},\n                \"releases\": {v: [{}] for v in versions},\n            },\n        )\n\n    return _mock\n\n\n# Usage in tests:\n@pytest.mark.asyncio\nasync def test_with_mock_factory(mock_pypi_package, checker):\n    mock_pypi_package(\"requests\", [\"2.28.0\", \"2.29.0\", \"2.31.0\"])\n\n    pkg = await checker.get_package_info(\"requests\")\n    assert pkg.latest_version == \"2.31.0\"\n</code></pre>"},{"location":"contributing/testing/#parametrized-tests","title":"Parametrized Tests","text":"<p>Use pytest.mark.parametrize to test multiple scenarios without code duplication:</p> Basic ParametrizationMultiple ParametersFixture Parametrization tests/unit/core/test_parser.py<pre><code>import pytest\n\n\n@pytest.mark.parametrize(\n    \"input_line,expected_name,expected_specs\",\n    [\n        (\"requests==2.28.0\", \"requests\", [(\"==\", \"2.28.0\")]),\n        (\"flask&gt;=2.0,&lt;3.0\", \"flask\", [(\"&gt;=\", \"2.0\"), (\"&lt;\", \"3.0\")]),\n        (\"click~=8.0\", \"click\", [(\"~=\", \"8.0\")]),\n        (\"numpy\", \"numpy\", []),\n        (\"Django&gt;=4.0\", \"django\", [(\"&gt;=\", \"4.0\")]),  # Normalized\n    ],\n    ids=[\n        \"pinned-version\",\n        \"version-range\",\n        \"compatible-release\",\n        \"no-version\",\n        \"case-normalization\",\n    ],\n)\ndef test_parse_version_specifiers(parser, input_line, expected_name, expected_specs):\n    \"\"\"Parser correctly handles various version specifier formats.\"\"\"\n    result = parser.parse_line(input_line, line_number=1)\n\n    assert result.name == expected_name\n    assert result.specs == expected_specs\n</code></pre> tests/unit/utils/test_version_utils.py<pre><code>import pytest\nfrom depkeeper.utils.version_utils import get_update_type\n\n\n@pytest.mark.parametrize(\"current,target,expected\", [\n    # Major version changes\n    (\"1.0.0\", \"2.0.0\", \"major\"),\n    (\"1.9.9\", \"2.0.0\", \"major\"),\n    # Minor version changes\n    (\"1.0.0\", \"1.1.0\", \"minor\"),\n    (\"1.0.5\", \"1.2.0\", \"minor\"),\n    # Patch version changes\n    (\"1.0.0\", \"1.0.1\", \"patch\"),\n    (\"1.2.3\", \"1.2.5\", \"patch\"),\n    # Edge cases\n    (\"1.0.0\", \"1.0.0\", \"same\"),\n    (\"2.0.0\", \"1.0.0\", \"downgrade\"),\n    (None, \"1.0.0\", \"new\"),\n])\ndef test_get_update_type(current, target, expected):\n    \"\"\"get_update_type correctly classifies version changes.\"\"\"\n    result = get_update_type(current, target)\n    assert result == expected\n</code></pre> tests/conftest.py<pre><code>import pytest\n\n\n@pytest.fixture(params=[\n    \"requirements.txt\",\n    \"requirements-dev.txt\",\n    \"requirements/base.txt\",\n])\ndef requirements_filename(request):\n    \"\"\"Test with various requirements file naming conventions.\"\"\"\n    return request.param\n</code></pre>"},{"location":"contributing/testing/#testing-errors-exceptions","title":"Testing Errors &amp; Exceptions","text":"<p>Verify error handling with explicit assertions:</p> tests/unit/core/test_parser_errors.py<pre><code>import pytest\nfrom depkeeper.exceptions import ParseError, InvalidVersionError\n\n\nclass TestParserErrors:\n    \"\"\"Tests for parser error handling.\"\"\"\n\n    def test_invalid_syntax_raises_parse_error(self, parser):\n        \"\"\"Parser raises ParseError with line info for invalid syntax.\"\"\"\n        with pytest.raises(ParseError) as exc_info:\n            parser.parse_line(\"invalid@@@\", line_number=42)\n\n        error = exc_info.value\n        assert \"Invalid requirement\" in str(error)\n        assert error.line_number == 42\n        assert error.line_content == \"invalid@@@\"\n\n    def test_invalid_version_provides_context(self, parser):\n        \"\"\"ParseError includes helpful context for invalid versions.\"\"\"\n        with pytest.raises(InvalidVersionError) as exc_info:\n            parser.parse_line(\"requests==not.a.version\", line_number=1)\n\n        assert \"not.a.version\" in str(exc_info.value)\n        assert exc_info.value.package_name == \"requests\"\n\n    @pytest.mark.parametrize(\"invalid_line\", [\n        \"===invalid\",\n        \"package==\",\n        \"@@@\",\n        \"git+invalid-url\",\n    ])\n    def test_various_invalid_inputs(self, parser, invalid_line):\n        \"\"\"Parser handles various invalid inputs gracefully.\"\"\"\n        with pytest.raises(ParseError):\n            parser.parse_line(invalid_line, line_number=1)\n</code></pre> <p>Testing Exception Hierarchy</p> <p>Use pytest.raises(YourBaseError) to catch any exception in your custom hierarchy, or be specific to ensure the exact exception type is raised. Avoid catching BaseException as it includes SystemExit and KeyboardInterrupt.</p>"},{"location":"contributing/testing/#integration-tests","title":"Integration Tests","text":"<p>Integration tests verify component interactions:</p> tests/integration/test_check_workflow.py<pre><code>import pytest\n\n\n@pytest.mark.asyncio\nclass TestCheckWorkflow:\n    \"\"\"Integration tests for the check command workflow.\"\"\"\n\n    async def test_full_check_workflow(\n        self,\n        sample_requirements_file,\n        httpx_mock,\n        mock_pypi_package,\n    ):\n        \"\"\"Check workflow parses, queries, and reports correctly.\"\"\"\n        # Arrange\n        mock_pypi_package(\"requests\", [\"2.28.0\", \"2.31.0\"])\n        mock_pypi_package(\"flask\", [\"2.3.0\"])\n        mock_pypi_package(\"click\", [\"8.0.0\", \"8.1.0\"])\n        mock_pypi_package(\"pytest\", [\"7.0.0\", \"7.4.0\"])\n\n        from depkeeper.core import RequirementsParser, VersionChecker, PyPIDataStore\n        from depkeeper.utils import HTTPClient\n\n        # Act\n        parser = RequirementsParser()\n        requirements = parser.parse_file(sample_requirements_file)\n\n        async with HTTPClient() as http:\n            store = PyPIDataStore(http)\n            checker = VersionChecker(data_store=store)\n            packages = await checker.check_packages(requirements)\n\n        # Assert\n        assert len(packages) == len(requirements)\n        outdated = [p for p in packages if p.update_available]\n        assert len(outdated) == 3  # requests, click, pytest\n\n    async def test_workflow_handles_partial_failures(\n        self,\n        sample_requirements_file,\n        httpx_mock,\n    ):\n        \"\"\"Workflow continues checking even if some packages fail.\"\"\"\n        # Mock one success, one failure\n        httpx_mock.add_response(\n            url=\"https://pypi.org/pypi/requests/json\",\n            json={\"info\": {\"name\": \"requests\", \"version\": \"2.31.0\"}, \"releases\": {}},\n        )\n        httpx_mock.add_response(\n            url=\"https://pypi.org/pypi/flask/json\",\n            status_code=500,\n        )\n        # ... remaining mocks\n\n        from depkeeper.core import RequirementsParser, VersionChecker, PyPIDataStore\n        from depkeeper.utils import HTTPClient\n\n        parser = RequirementsParser()\n        requirements = parser.parse_file(sample_requirements_file)\n\n        async with HTTPClient() as http:\n            store = PyPIDataStore(http)\n            checker = VersionChecker(data_store=store)\n            result = await checker.check_packages(requirements)\n\n        # Should still return results for successful packages\n        assert any(p.name == \"requests\" for p in result.packages)\n        assert any(e.name == \"flask\" for e in result.errors)\n</code></pre>"},{"location":"contributing/testing/#cli-end-to-end-tests","title":"CLI End-to-End Tests","text":"<p>Test CLI behavior using Click's test runner:</p> Basic CLI TestsTesting Output FormatsInteractive Tests tests/e2e/test_cli.py<pre><code>import pytest\nfrom click.testing import CliRunner\nfrom depkeeper.cli import cli\n\n\nclass TestCheckCommand:\n    \"\"\"E2E tests for the check command.\"\"\"\n\n    @pytest.fixture\n    def runner(self):\n        return CliRunner()\n\n    def test_check_shows_outdated_packages(self, runner, httpx_mock):\n        \"\"\"Check command displays outdated packages.\"\"\"\n        with runner.isolated_filesystem():\n            # Create requirements file\n            with open(\"requirements.txt\", \"w\") as f:\n                f.write(\"requests==2.28.0\\n\")\n\n            # Mock PyPI\n            # Note: May need to configure httpx_mock for CLI tests\n\n            result = runner.invoke(cli, [\"check\"])\n\n            assert result.exit_code == 0\n            assert \"requests\" in result.output\n\n    def test_check_returns_success_with_outdated(self, runner):\n        \"\"\"Check returns exit code 0 even when updates are available.\"\"\"\n        with runner.isolated_filesystem():\n            with open(\"requirements.txt\", \"w\") as f:\n                f.write(\"requests==2.28.0\\n\")\n\n            result = runner.invoke(cli, [\"check\"])\n\n            # Exit code 0 indicates successful execution\n            assert result.exit_code == 0\n\n    def test_check_missing_file_shows_error(self, runner):\n        \"\"\"Check command shows helpful error for missing file.\"\"\"\n        with runner.isolated_filesystem():\n            result = runner.invoke(cli, [\"check\"])\n\n            assert result.exit_code != 0\n            assert \"requirements.txt\" in result.output\n            assert \"not found\" in result.output.lower()\n</code></pre> tests/e2e/test_cli_output.py<pre><code>import json\nimport pytest\nfrom click.testing import CliRunner\nfrom depkeeper.cli import cli\n\n\nclass TestOutputFormats:\n    \"\"\"Tests for different output format options.\"\"\"\n\n    @pytest.fixture\n    def runner(self):\n        return CliRunner()\n\n    def test_json_output_is_valid(self, runner):\n        \"\"\"JSON output is valid and parseable.\"\"\"\n        with runner.isolated_filesystem():\n            with open(\"requirements.txt\", \"w\") as f:\n                f.write(\"requests==2.28.0\\n\")\n\n            result = runner.invoke(cli, [\"check\", \"--format\", \"json\"])\n\n            # Should be valid JSON\n            data = json.loads(result.output)\n            assert isinstance(data, list)\n            assert all(\"name\" in pkg for pkg in data)\n\n    def test_quiet_mode_minimal_output(self, runner):\n        \"\"\"Quiet mode produces minimal output.\"\"\"\n        with runner.isolated_filesystem():\n            with open(\"requirements.txt\", \"w\") as f:\n                f.write(\"requests==2.28.0\\n\")\n\n            result = runner.invoke(cli, [\"check\", \"-q\"])\n\n            # Should have minimal output\n            lines = [l for l in result.output.strip().split(\"\\n\") if l]\n            assert len(lines) &lt;= 5\n\n    def test_verbose_shows_debug_info(self, runner):\n        \"\"\"Verbose mode includes debug information.\"\"\"\n        with runner.isolated_filesystem():\n            with open(\"requirements.txt\", \"w\") as f:\n                f.write(\"requests==2.28.0\\n\")\n\n            result = runner.invoke(cli, [\"check\", \"-v\"])\n\n            # Should include extra info\n            assert \"Parsing\" in result.output or \"Checking\" in result.output\n</code></pre> tests/e2e/test_cli_interactive.py<pre><code>import pytest\nfrom click.testing import CliRunner\nfrom depkeeper.cli import cli\n\n\nclass TestInteractiveCommands:\n    \"\"\"Tests for commands requiring user input.\"\"\"\n\n    @pytest.fixture\n    def runner(self):\n        return CliRunner(mix_stderr=False)\n\n    def test_update_prompts_for_confirmation(self, runner):\n        \"\"\"Update command asks for confirmation by default.\"\"\"\n        with runner.isolated_filesystem():\n            with open(\"requirements.txt\", \"w\") as f:\n                f.write(\"requests==2.28.0\\n\")\n\n            # Simulate user typing 'n' for no\n            result = runner.invoke(cli, [\"update\"], input=\"n\\n\")\n\n            assert \"Proceed?\" in result.output or \"Continue?\" in result.output\n            assert \"Aborted\" in result.output or \"Cancelled\" in result.output\n\n    def test_update_yes_flag_skips_prompt(self, runner):\n        \"\"\"Update --yes flag bypasses confirmation.\"\"\"\n        with runner.isolated_filesystem():\n            with open(\"requirements.txt\", \"w\") as f:\n                f.write(\"requests==2.28.0\\n\")\n\n            result = runner.invoke(cli, [\"update\", \"--yes\", \"--dry-run\"])\n\n            # Should not ask for confirmation\n            assert \"Proceed?\" not in result.output\n</code></pre>"},{"location":"contributing/testing/#test-markers","title":"Test Markers","text":"<p>Use markers to categorize and selectively run tests:</p> tests/conftest.py<pre><code>import pytest\n\n\ndef pytest_configure(config):\n    \"\"\"Register custom markers.\"\"\"\n    config.addinivalue_line(\"markers\", \"unit: Unit tests (fast, isolated)\")\n    config.addinivalue_line(\"markers\", \"integration: Integration tests\")\n    config.addinivalue_line(\"markers\", \"e2e: End-to-end CLI tests\")\n    config.addinivalue_line(\"markers\", \"slow: Slow-running tests\")\n    config.addinivalue_line(\"markers\", \"network: Requires network access\")\n</code></pre> tests/unit/test_parser.py<pre><code>import pytest\n\n\n@pytest.mark.unit\nclass TestParser:\n    \"\"\"Unit tests for RequirementsParser.\"\"\"\n\n    def test_parse_simple(self, parser):\n        ...\n\n\n@pytest.mark.slow\ndef test_parse_large_file(parser, large_requirements_file):\n    \"\"\"Test parsing a file with 1000+ requirements.\"\"\"\n    ...\n</code></pre>"},{"location":"contributing/testing/#running-tests-by-marker","title":"Running Tests by Marker","text":"Bash<pre><code># Run only unit tests\npytest -m \"unit\"\n\n# Skip slow tests\npytest -m \"not slow\"\n\n# Run integration tests only\npytest -m \"integration\"\n\n# Combine markers\npytest -m \"unit and not slow\"\n</code></pre>"},{"location":"contributing/testing/#code-coverage","title":"Code Coverage","text":""},{"location":"contributing/testing/#running-coverage","title":"Running Coverage","text":"Command LineOpening Reports Bash<pre><code># Run with coverage\npytest --cov=depkeeper\n\n# Generate HTML report\npytest --cov=depkeeper --cov-report=html\n\n# Generate XML for CI tools\npytest --cov=depkeeper --cov-report=xml\n\n# Fail if coverage below threshold\npytest --cov=depkeeper --cov-fail-under=85\n</code></pre> Bash<pre><code># macOS\nopen htmlcov/index.html\n\n# Linux\nxdg-open htmlcov/index.html\n\n# Windows\nstart htmlcov/index.html\n</code></pre>"},{"location":"contributing/testing/#coverage-configuration","title":"Coverage Configuration","text":"pyproject.toml<pre><code>[tool.coverage.run]\nsource = [\"depkeeper\"]\nomit = [\n    \"*/tests/*\",\n    \"*/__pycache__/*\",\n    \"*/site-packages/*\",\n]\n\n[tool.coverage.report]\nprecision = 2\nshow_missing = true\nskip_covered = false\n\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n    \"if __name__ == .__main__.:\",\n    \"if TYPE_CHECKING:\",\n    \"@abstractmethod\",\n    \"@abc.abstractmethod\",\n]\n\n[tool.coverage.html]\ndirectory = \"htmlcov\"\n\n[tool.coverage.xml]\noutput = \"coverage.xml\"\n</code></pre>"},{"location":"contributing/testing/#coverage-targets","title":"Coverage Targets","text":"Scope Minimum Target Overall 85% 90%+ Critical Paths 95% 100% New Code 90% 95% <p>Critical Paths Requiring 100% Coverage</p> <ul> <li><code>core/parser.py</code> - Requirement parsing</li> <li><code>core/checker.py</code> - Version checking</li> <li><code>core/data_store.py</code> - PyPI data retrieval</li> <li><code>core/dependency_analyzer.py</code> - Dependency resolution</li> <li><code>commands/update.py</code> - File modification and updates</li> </ul>"},{"location":"contributing/testing/#best-practices","title":"Best Practices","text":""},{"location":"contributing/testing/#do","title":"Do","text":"<ul> <li>Write one assertion group per test - Tests should verify one behavior</li> <li>Use descriptive test names - Names should explain what is being tested</li> <li>Use fixtures - Avoid duplicating setup code</li> <li>Mock external services - Tests should be deterministic</li> <li>Test edge cases - Empty inputs, large files, special characters</li> <li>Test error paths - Verify errors are handled gracefully</li> <li>Keep tests fast - Unit tests should run in milliseconds</li> <li>Use parametrize - Reduce duplication for similar tests</li> </ul>"},{"location":"contributing/testing/#avoid","title":"Avoid","text":"<ul> <li>Testing implementation details - Test behavior, not internals</li> <li>Relying on test order - Tests should be independent</li> <li>Hard-coded paths - Use tmp_path fixture</li> <li>Skipping cleanup - Use fixtures with proper teardown</li> <li>Ignoring warnings - Treat warnings as errors in CI</li> <li>Flaky tests - Fix or mark tests that intermittently fail</li> <li>Overly complex fixtures - Keep fixtures simple and focused</li> </ul>"},{"location":"contributing/testing/#troubleshooting","title":"Troubleshooting","text":"Tests pass locally but fail in CI <p>Common causes and solutions:</p> <ul> <li> <p>Path handling differences</p> <ul> <li>Cause: Hardcoded paths like <code>C:\\Users\\...</code> or <code>/home/user/...</code> fail on other OS</li> <li>Solution: Always use <code>pathlib.Path</code> and <code>tmp_path</code> fixture: Python<pre><code>from pathlib import Path\n\n# Bad - OS-specific\npath = \"/home/user/file.txt\"\n\n# Good - OS-agnostic\npath = Path(\"file.txt\")\npath = tmp_path / \"file.txt\"\n</code></pre></li> </ul> </li> <li> <p>Line ending differences</p> <ul> <li>Cause: Windows uses CRLF (<code>\\r\\n</code>), Unix uses LF (<code>\\n</code>)</li> <li>Solution: Open files with explicit newline handling: Python<pre><code>with open(file_path, \"w\", newline=\"\\n\") as f:\n    f.write(content)\n</code></pre></li> </ul> </li> <li> <p>Missing dependencies</p> <ul> <li>Cause: Dev dependencies not installed in CI</li> <li>Solution: Ensure <code>pip install -e \".[dev]\"</code> is in CI config</li> </ul> </li> <li> <p>Async timing issues</p> <ul> <li>Cause: Race conditions or timeouts differ across environments</li> <li>Solution: Use deterministic mocks instead of real delays</li> </ul> </li> </ul> Coverage is lower in CI than locally <p>Common causes and solutions:</p> <ul> <li> <p>Different Python versions</p> <ul> <li>Cause: Branch coverage differs between Python versions</li> <li>Solution: Pin Python version in CI to match local development</li> </ul> </li> <li> <p>Missing test files</p> <ul> <li>Cause: Test discovery not finding all files</li> <li>Solution: Verify <code>pytest.ini</code> or <code>pyproject.toml</code> has correct <code>testpaths</code></li> </ul> </li> <li> <p>Inconsistent coverage config</p> <ul> <li>Cause: Different <code>pyproject.toml</code> settings</li> <li>Solution: Commit <code>pyproject.toml</code> and ensure same config everywhere</li> </ul> </li> <li> <p>Parallel test execution</p> <ul> <li>Cause: <code>pytest-xdist</code> can affect coverage collection</li> <li>Solution: Use <code>--cov-append</code> with parallel tests</li> </ul> </li> </ul> Tests are slow <p>Common causes and solutions:</p> <ul> <li> <p>Real network calls</p> <ul> <li>Cause: Tests hitting actual APIs instead of mocks</li> <li>Solution: Mock all external services with <code>httpx_mock</code> or <code>responses</code></li> </ul> </li> <li> <p>Excessive fixture scope</p> <ul> <li>Cause: Using <code>function</code> scope when <code>module</code> or <code>session</code> would work</li> <li>Solution: Use broader scopes for expensive, immutable fixtures</li> </ul> </li> <li> <p>No parallelization</p> <ul> <li>Cause: Tests running sequentially</li> <li>Solution: Install <code>pytest-xdist</code> and run <code>pytest -n auto</code></li> </ul> </li> <li> <p>Finding slow tests</p> <ul> <li>Run <code>pytest --durations=10</code> to identify the slowest tests</li> <li>Consider marking slow tests with <code>@pytest.mark.slow</code> and skipping in dev</li> </ul> </li> </ul> httpx_mock not working in CLI tests <p>Cause: Click's <code>CliRunner</code> runs in an isolated environment that doesn't share the same event loop or mock context.</p> <p>Solutions:</p> <ul> <li> <p>Use dependency injection</p> <ul> <li>Pass mock clients through the CLI context or environment variables</li> </ul> </li> <li> <p>Set up mocks inside isolated filesystem Python<pre><code>def test_cli_with_mock(runner, httpx_mock):\n    with runner.isolated_filesystem():\n        httpx_mock.add_response(url=\"...\", json={...})\n        result = runner.invoke(cli, [\"check\"])\n</code></pre></p> </li> <li> <p>Use subprocess for true E2E</p> <ul> <li>For full integration tests, run CLI as subprocess with mocked server</li> </ul> </li> </ul> Import errors or module not found <p>Common causes and solutions:</p> <ul> <li> <p>Package not installed in editable mode</p> <ul> <li>Cause: Running tests without installing the package</li> <li>Solution: Run <code>pip install -e .</code> before testing</li> </ul> </li> <li> <p>Circular imports</p> <ul> <li>Cause: Test imports triggering circular dependencies</li> <li>Solution: Import inside test functions or use <code>TYPE_CHECKING</code></li> </ul> </li> <li> <p>Python path issues</p> <ul> <li>Cause: Working directory not in Python path</li> <li>Solution: Run pytest from project root or configure <code>pythonpath</code> in <code>pyproject.toml</code></li> </ul> </li> </ul> Fixtures not found <p>Common causes and solutions:</p> <ul> <li> <p>Wrong conftest.py location</p> <ul> <li>Cause: Fixture defined in wrong <code>conftest.py</code> or not at all</li> <li>Solution: Place shared fixtures in <code>tests/conftest.py</code></li> </ul> </li> <li> <p>Scope mismatch</p> <ul> <li>Cause: Session-scoped fixture depending on function-scoped fixture</li> <li>Solution: Ensure fixture scope hierarchy is correct</li> </ul> </li> <li> <p>Missing fixture import</p> <ul> <li>Cause: Fixture from plugin not available</li> <li>Solution: Install required plugins: <code>pytest-httpx</code>, <code>pytest-asyncio</code></li> </ul> </li> </ul>"},{"location":"contributing/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Code Style -- Follow coding standards and formatting requirements</li> <li>Development Setup -- Set up your local development environment</li> <li>Release Process -- Understand how releases are planned and published</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to depkeeper! This section will help you get up and running quickly.</p>"},{"location":"getting-started/#overview","title":"Overview","text":"<p>depkeeper is a modern Python dependency management tool that helps you:</p> <ul> <li>Check your <code>requirements.txt</code> for available updates</li> <li>Update packages safely without breaking changes</li> <li>Resolve dependency conflicts automatically</li> <li>Integrate seamlessly into CI/CD pipelines</li> </ul>"},{"location":"getting-started/#quick-links","title":"Quick Links","text":"<ul> <li> <p> Installation</p> <p>Install depkeeper via pip, pipx, or from source.</p> <p> Install now</p> </li> <li> <p> Quick Start</p> <p>Get running in under 5 minutes with essential commands.</p> <p> Start here</p> </li> <li> <p> Basic Usage</p> <p>Learn the fundamentals of checking and updating dependencies.</p> <p> Learn basics</p> </li> </ul>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<p>Before installing depkeeper, ensure you have:</p> Requirement Version Python 3.8 or higher pip 21.0 or higher (recommended) OS Windows, macOS, or Linux <p>Check your Python version</p> Bash<pre><code>python --version\n# Python 3.11.4\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>After completing the getting started guides, explore:</p> <ul> <li>User Guide -- In-depth feature documentation</li> <li>CLI Reference -- Complete command reference</li> <li>CI/CD Integration -- Automate dependency updates</li> </ul>"},{"location":"getting-started/basic-usage/","title":"Basic Usage","text":"<p>This guide covers the fundamental concepts and workflows for using depkeeper effectively.</p>"},{"location":"getting-started/basic-usage/#understanding-requirements-files","title":"Understanding Requirements Files","text":"<p>depkeeper works with standard <code>requirements.txt</code> files that pip understands. It supports:</p> Text Only<pre><code># Basic version pinning\nrequests==2.31.0\nflask&gt;=2.0.0,&lt;3.0.0\n\n# With extras\ncelery[redis]==5.3.0\n\n# Environment markers\npywin32==306; sys_platform == 'win32'\n\n# Include other files\n-r base.txt\n-c constraints.txt\n\n# VCS URLs\ngit+https://github.com/user/repo.git@v1.0.0#egg=mypackage\n\n# Editable installs\n-e ./local-package\n</code></pre>"},{"location":"getting-started/basic-usage/#the-check-command","title":"The <code>check</code> Command","text":"<p>The <code>check</code> command analyzes your requirements file and reports available updates.</p>"},{"location":"getting-started/basic-usage/#basic-check","title":"Basic Check","text":"Bash<pre><code>depkeeper check\n</code></pre> <p>By default, this reads <code>requirements.txt</code> in the current directory.</p>"},{"location":"getting-started/basic-usage/#check-a-specific-file","title":"Check a Specific File","text":"Bash<pre><code>depkeeper check requirements-dev.txt\ndepkeeper check path/to/requirements.txt\n</code></pre>"},{"location":"getting-started/basic-usage/#output-formats","title":"Output Formats","text":"Table (default)SimpleJSON Bash<pre><code>depkeeper check --format table\n</code></pre> Text Only<pre><code>                                    Dependency Status\n\n  Status       Package    Current   Latest   Recommended   Update Type   Conflicts   Python Support\n\n  \u2713 OK         django      3.2.0     5.0.2        -             -           -        Current: &gt;=3.8\n                                                                                     Latest: &gt;=3.10\n\n  \u2b06 OUTDATED   requests    2.28.0    2.32.0     2.32.0        minor         -        Current: &gt;=3.7\n                                                                                     Latest: &gt;=3.8\n\n  \u2b06 OUTDATED   flask       2.0.0     3.0.1      2.3.3         patch         -        Current: &gt;=3.7\n                                                                                     Latest: &gt;=3.8\n\n[WARNING] 2 package(s) have updates available\n</code></pre> Bash<pre><code>depkeeper check --format simple\n</code></pre> Text Only<pre><code> requests             2.28.0     \u2192 2.32.0     (recommended: 2.32.0)\n       Python: installed: &gt;=3.7, latest: &gt;=3.8\n flask                2.0.0      \u2192 3.0.1      (recommended: 2.3.3)\n       Python: installed: &gt;=3.7, latest: &gt;=3.8, recommended: &gt;=3.7\n celery               5.3.0      \u2192 5.3.6\n       Python: installed: &gt;=3.8, latest: &gt;=3.8\n</code></pre> <p>Each line shows the package name, installed version, latest version, and a recommended version when it differs from the latest. The indented Python line shows the required Python version for each relevant release.</p> Bash<pre><code>depkeeper check --format json\n</code></pre> JSON<pre><code>[\n  {\n    \"name\": \"requests\",\n    \"status\": \"latest\",\n    \"versions\": {\n      \"current\": \"2.32.5\",\n      \"latest\": \"2.32.5\",\n      \"recommended\": \"2.32.5\"\n    },\n    \"python_requirements\": {\n      \"current\": \"&gt;=3.9\",\n      \"latest\": \"&gt;=3.9\",\n      \"recommended\": \"&gt;=3.9\"\n    }\n  },\n  {\n    \"name\": \"polars\",\n    \"status\": \"outdated\",\n    \"versions\": {\n      \"current\": \"1.37.1\",\n      \"latest\": \"1.38.1\",\n      \"recommended\": \"1.38.1\"\n    },\n    \"update_type\": \"minor\",\n    \"python_requirements\": {\n      \"current\": \"&gt;=3.10\",\n      \"latest\": \"&gt;=3.10\",\n      \"recommended\": \"&gt;=3.10\"\n    }\n  },\n  {\n    \"name\": \"setuptools\",\n    \"status\": \"latest\",\n    \"versions\": {\n      \"current\": \"80.10.2\",\n      \"latest\": \"82.0.0\",\n      \"recommended\": \"80.10.2\"\n    },\n    \"python_requirements\": {\n      \"current\": \"&gt;=3.9\",\n      \"latest\": \"&gt;=3.9\",\n      \"recommended\": \"&gt;=3.9\"\n    }\n  }\n]\n</code></pre> <p>Each object includes the package <code>name</code>, its <code>status</code> (<code>latest</code> or <code>outdated</code>), a <code>versions</code> block with <code>current</code>, <code>latest</code>, and <code>recommended</code> versions, and a <code>python_requirements</code> block showing the required Python version for each release. Outdated packages also include an <code>update_type</code> field (<code>patch</code>, <code>minor</code>, or <code>major</code>).</p>"},{"location":"getting-started/basic-usage/#filter-to-outdated-only","title":"Filter to Outdated Only","text":"<p>Show only packages that need updates:</p> Bash<pre><code>depkeeper check --outdated-only\n</code></pre>"},{"location":"getting-started/basic-usage/#the-update-command","title":"The <code>update</code> Command","text":"<p>The <code>update</code> command applies safe version updates to your requirements file.</p>"},{"location":"getting-started/basic-usage/#basic-update","title":"Basic Update","text":"Bash<pre><code>depkeeper update\n</code></pre> <p>This:</p> <ol> <li>Checks all packages for updates</li> <li>Shows a preview of changes</li> <li>Asks for confirmation</li> <li>Updates <code>requirements.txt</code></li> </ol>"},{"location":"getting-started/basic-usage/#preview-mode-dry-run","title":"Preview Mode (Dry Run)","text":"<p>See what would change without modifying files:</p> Bash<pre><code>depkeeper update --dry-run\n</code></pre>"},{"location":"getting-started/basic-usage/#skip-confirmation","title":"Skip Confirmation","text":"<p>Auto-approve updates (useful for CI/CD):</p> Bash<pre><code>depkeeper update --yes\n# or\ndepkeeper update -y\n</code></pre>"},{"location":"getting-started/basic-usage/#create-backup","title":"Create Backup","text":"<p>Create a timestamped backup before updating:</p> Bash<pre><code>depkeeper update --backup\n</code></pre> <p>This creates <code>requirements.txt.backup.20260208-143022</code> (with current timestamp).</p>"},{"location":"getting-started/basic-usage/#update-specific-packages","title":"Update Specific Packages","text":"<p>Update only selected packages:</p> Bash<pre><code># Single package\ndepkeeper update -p requests\n\n# Multiple packages\ndepkeeper update -p requests -p flask -p click\n</code></pre>"},{"location":"getting-started/basic-usage/#version-boundary-safety","title":"Version Boundary Safety","text":"<p>A key feature of depkeeper is major version boundary protection.</p>"},{"location":"getting-started/basic-usage/#what-this-means","title":"What This Means","text":"<p>depkeeper never recommends crossing a major version boundary automatically:</p> Current Latest Recommended Reason <code>2.28.0</code> <code>2.32.0</code> <code>2.32.0</code> Same major (2.x) \u2713 <code>2.0.0</code> <code>3.0.1</code> <code>2.3.3</code> Stays on 2.x, avoids 3.x breaking changes <code>1.2.3</code> <code>2.0.0</code> <code>1.9.9</code> Stays on 1.x"},{"location":"getting-started/basic-usage/#why-this-matters","title":"Why This Matters","text":"<p>Major version updates often include:</p> <ul> <li>Breaking API changes</li> <li>Removed functionality</li> <li>Changed behavior</li> <li>Incompatible dependencies</li> </ul> <p>By staying within the same major version, depkeeper keeps your environment stable while still getting bug fixes and security patches.</p> <p>Intentional Major Upgrades</p> <p>When you're ready to upgrade to a new major version, update your <code>requirements.txt</code> manually and test thoroughly.</p>"},{"location":"getting-started/basic-usage/#conflict-detection","title":"Conflict Detection","text":"<p>depkeeper automatically detects dependency conflicts.</p>"},{"location":"getting-started/basic-usage/#how-it-works","title":"How It Works","text":"<p>When checking or updating, depkeeper:</p> <ol> <li>Fetches dependency metadata from PyPI</li> <li>Builds a dependency graph</li> <li>Identifies version conflicts</li> <li>Adjusts recommendations to resolve conflicts</li> </ol>"},{"location":"getting-started/basic-usage/#example","title":"Example","text":"Text Only<pre><code>                                         Dependency Status\n\n  Status       Package           Current   Latest   Recommended   Update Type   Conflicts                        Python Support\n\n  \u2b06 OUTDATED   pytest-asyncio     0.3.0     1.3.0     0.23.8        minor         -                             Latest: &gt;=3.10\n                                                                                                                Recommended: &gt;=3.8\n\n  \u2b06 OUTDATED   pytest             7.0.2     9.0.2     7.4.4         minor    pytest-asyncio needs &gt;= 7.0.0,&lt;9      Latest: &gt;=3.10\n                                                                                                                Recommended: &gt;=3.7\n\n[WARNING] 2 package(s) have updates available\n</code></pre> <p>In this example, <code>pytest</code> is constrained by <code>pytest-asyncio</code> which requires <code>pytest&gt;=8.2,&lt;9</code>. depkeeper detects this conflict and adjusts the recommended version of <code>pytest</code> to stay within safe boundaries.</p>"},{"location":"getting-started/basic-usage/#disabling-conflict-checking","title":"Disabling Conflict Checking","text":"<p>For faster checks without resolution:</p> Bash<pre><code>depkeeper check --no-check-conflicts\ndepkeeper update --no-check-conflicts\n</code></pre> <p>Warning</p> <p>Disabling conflict checking may result in broken environments.</p>"},{"location":"getting-started/basic-usage/#working-with-multiple-files","title":"Working with Multiple Files","text":""},{"location":"getting-started/basic-usage/#multiple-requirements-files","title":"Multiple Requirements Files","text":"<p>Check or update different files:</p> Bash<pre><code>depkeeper check requirements.txt\ndepkeeper check requirements-dev.txt\ndepkeeper check requirements-test.txt\n</code></pre>"},{"location":"getting-started/basic-usage/#included-files","title":"Included Files","text":"<p>If your requirements file uses <code>-r</code> includes:</p> Text Only<pre><code># requirements-dev.txt\n-r requirements.txt\npytest&gt;=7.0.0\nblack&gt;=23.0.0\n</code></pre> <p>depkeeper follows include directives and processes all referenced files.</p>"},{"location":"getting-started/basic-usage/#constraint-files","title":"Constraint Files","text":"<p>Constraint files (<code>-c</code>) are also supported:</p> Text Only<pre><code># requirements.txt\n-c constraints.txt\nrequests\nflask\n</code></pre>"},{"location":"getting-started/basic-usage/#exit-codes","title":"Exit Codes","text":"<p>depkeeper uses meaningful exit codes:</p> Code Meaning <code>0</code> Success <code>1</code> Error (parse failure, network issue, etc.) <code>2</code> Usage error (invalid arguments) <code>130</code> Interrupted by user (Ctrl+C) <p>Useful for CI/CD scripts:</p> Bash<pre><code>depkeeper check --format json || echo \"Check failed\"\n</code></pre>"},{"location":"getting-started/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Checking Updates -- Deep dive into the check command</li> <li>Updating Dependencies -- Advanced update workflows</li> <li>Dependency Resolution -- Understand conflict detection</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>depkeeper can be installed using several methods. Choose the one that best fits your workflow.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python: 3.8 or higher</li> <li>Operating System: Windows, macOS, or Linux</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#pip-recommended","title":"pip (Recommended)","text":"<p>The simplest way to install depkeeper is via pip:</p> Bash<pre><code>pip install depkeeper\n</code></pre> <p>To install with specific version:</p> Bash<pre><code>pip install depkeeper==0.1.0\n</code></pre>"},{"location":"getting-started/installation/#pipx-isolated-environment","title":"pipx (Isolated Environment)","text":"<p>For CLI tools, pipx installs packages in isolated environments:</p> Bash<pre><code># Install pipx if you haven't\npip install pipx\npipx ensurepath\n\n# Install depkeeper\npipx install depkeeper\n</code></pre> <p>Why pipx?</p> <p>pipx is ideal for CLI tools like depkeeper because it:</p> <ul> <li>Isolates dependencies from your global environment</li> <li>Automatically creates and manages virtual environments</li> <li>Makes the <code>depkeeper</code> command available globally</li> </ul>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>For development or to get the latest features:</p> Bash<pre><code># Clone the repository\ngit clone https://github.com/rahulkaushal04/depkeeper.git\ncd depkeeper\n\n# Install in development mode\npip install -e .\n\n# Or with development dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#using-poetry","title":"Using Poetry","text":"<p>If your project uses Poetry:</p> Bash<pre><code>poetry add depkeeper\n</code></pre>"},{"location":"getting-started/installation/#using-uv","title":"Using uv","text":"<p>For the fast uv package manager:</p> Bash<pre><code>uv pip install depkeeper\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that depkeeper is working:</p> Bash<pre><code># Check version\ndepkeeper --version\n# depkeeper 0.1.0\n\n# View available commands\ndepkeeper --help\n</code></pre> <p>Expected output:</p> Text Only<pre><code>Usage: depkeeper [OPTIONS] COMMAND [ARGS]...\n\n  depkeeper -- modern dependency management for requirements.txt files.\n\n  Available commands:\n    depkeeper check              Check for available updates\n    depkeeper update             Update packages to newer versions\n\n  Examples:\n    depkeeper check\n    depkeeper update\n    depkeeper -v check\n\n  Use ``depkeeper COMMAND --help`` for command-specific options.\n\nOptions:\n  -c, --config PATH       Path to configuration file.\n  -v, --verbose           Increase verbosity (can be repeated: -v, -vv).\n  --color / --no-color    Enable or disable colored output.\n  --version               Show the version and exit.\n  -h, --help              Show this message and exit.\n\nCommands:\n  check   Check for available updates in requirements file.\n  update  Update packages to newer versions.\n</code></pre>"},{"location":"getting-started/installation/#upgrading","title":"Upgrading","text":"<p>To upgrade to the latest version:</p> pippipx Bash<pre><code>pip install --upgrade depkeeper\n</code></pre> Bash<pre><code>pipx upgrade depkeeper\n</code></pre>"},{"location":"getting-started/installation/#uninstalling","title":"Uninstalling","text":"<p>To remove depkeeper:</p> pippipx Bash<pre><code>pip uninstall depkeeper\n</code></pre> Bash<pre><code>pipx uninstall depkeeper\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#command-not-found","title":"Command Not Found","text":"<p>If <code>depkeeper</code> is not found after installation:</p> <ol> <li> <p>Check pip installation location:    Bash<pre><code>pip show depkeeper\n</code></pre></p> </li> <li> <p>Ensure pip's bin directory is in PATH:</p> Linux/macOSWindows Bash<pre><code>export PATH=\"$HOME/.local/bin:$PATH\"\n</code></pre> <p>Add <code>%USERPROFILE%\\AppData\\Local\\Programs\\Python\\Python3X\\Scripts</code> to your PATH.</p> </li> <li> <p>Try running as a module:</p> </li> </ol> Bash<pre><code>python -m depkeeper --version\n</code></pre>"},{"location":"getting-started/installation/#permission-errors","title":"Permission Errors","text":"<p>If you encounter permission errors:</p> Bash<pre><code># Use --user flag\npip install --user depkeeper\n\n# Or use a virtual environment (recommended)\npython -m venv venv\nsource venv/bin/activate  # Linux/macOS\nvenv\\Scripts\\activate     # Windows\npip install depkeeper\n</code></pre>"},{"location":"getting-started/installation/#ssl-certificate-errors","title":"SSL Certificate Errors","text":"<p>If you're behind a corporate proxy:</p> Bash<pre><code>pip install --trusted-host pypi.org --trusted-host pypi.python.org depkeeper\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li> Quick Start -- Your first depkeeper commands</li> <li> Basic Usage -- Learn the fundamentals</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide gets you productive with depkeeper in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>A <code>requirements.txt</code> file in your project</li> </ul>"},{"location":"getting-started/quickstart/#step-1-install-depkeeper","title":"Step 1: Install depkeeper","text":"Bash<pre><code>pip install depkeeper\n</code></pre> <p>Verify the installation:</p> Bash<pre><code>depkeeper --version\n</code></pre>"},{"location":"getting-started/quickstart/#step-2-check-for-updates","title":"Step 2: Check for Updates","text":"<p>Navigate to your project directory and run:</p> Bash<pre><code>depkeeper check\n</code></pre> <p>You'll see output like:</p> Text Only<pre><code>Resolution Summary:\n==================================================\nTotal packages: 5\nPackages with conflicts: 0\nPackages changed: 0\nConverged: Yes (1 iterations)\n\n                                    Dependency Status\n\n  Status       Package    Current   Latest   Recommended   Update Type   Conflicts   Python Support\n\n  \u2713 OK         django      3.2.0     5.0.2        -             -           -        Current: &gt;=3.8\n                                                                                     Latest: &gt;=3.10\n\n  \u2b06 OUTDATED   requests    2.28.0    2.32.0     2.32.0        minor         -        Current: &gt;=3.7\n                                                                                     Latest: &gt;=3.8\n\n  \u2b06 OUTDATED   flask       2.0.0     3.0.1      2.3.3         patch         -        Current: &gt;=3.7\n                                                                                     Latest: &gt;=3.8\n\n  \u2b06 OUTDATED   click       8.0.0     8.1.7      8.1.7         minor         -        Current: &gt;=3.7\n                                                                                     Latest: &gt;=3.7\n\n  \u2b06 OUTDATED   pytest      7.4.0     8.0.0      7.4.4         patch         -        Current: &gt;=3.7\n                                                                                     Latest: &gt;=3.8\n\n[WARNING] 4 package(s) have updates available\n</code></pre> <p>Understanding the output</p> <ul> <li>Status: Whether the package is up to date (<code>\u2713 OK</code>) or has updates (<code>\u2b06 OUTDATED</code>)</li> <li>Current: Your pinned/installed version</li> <li>Latest: Newest version available on PyPI</li> <li>Recommended: Safe upgrade that respects major version boundaries</li> <li>Update Type: Severity of the update (major/minor/patch)</li> <li>Conflicts: Any dependency conflicts detected</li> <li>Python Support: Python version requirements for current, latest, and recommended versions</li> </ul>"},{"location":"getting-started/quickstart/#step-3-preview-updates","title":"Step 3: Preview Updates","text":"<p>Before making changes, preview what would be updated:</p> Bash<pre><code>depkeeper update --dry-run\n</code></pre> <p>Output:</p> Text Only<pre><code>                       Update Plan (Dry Run)\n\n  Package    Current   New Version   Change   Python Requires\n\n  requests    2.28.0       2.32.0    minor    &gt;=3.8\n  flask       2.0.0        2.3.3     patch    &gt;=3.8\n  click       8.0.0        8.1.7     minor    &gt;=3.7\n\n[WARNING] Dry run mode - no changes applied\n</code></pre>"},{"location":"getting-started/quickstart/#step-4-apply-updates","title":"Step 4: Apply Updates","text":"<p>When you're ready to update:</p> Bash<pre><code>depkeeper update\n</code></pre> <p>You'll see the update plan and be asked to confirm:</p> Text Only<pre><code>                          Update Plan\n\n  Package    Current   New Version   Change   Python Requires\n\n  requests    2.28.0       2.32.0    minor    &gt;=3.8\n  flask       2.0.0        2.3.3     patch    &gt;=3.8\n  click       8.0.0        8.1.7     minor    &gt;=3.7\n\nUpdate 3 packages? (y, n) [y]: y\n\n[OK] \u2713 Successfully updated 3 package(s)\n</code></pre> <p>To skip the confirmation prompt:</p> Bash<pre><code>depkeeper update -y\n</code></pre>"},{"location":"getting-started/quickstart/#step-5-create-a-backup-optional","title":"Step 5: Create a Backup (Optional)","text":"<p>For extra safety, create a backup before updating:</p> Bash<pre><code>depkeeper update --backup -y\n</code></pre> <p>This creates <code>requirements.txt.backup.&lt;timestamp&gt;</code> before making changes.</p>"},{"location":"getting-started/quickstart/#common-workflows","title":"Common Workflows","text":""},{"location":"getting-started/quickstart/#check-only-outdated-packages","title":"Check Only Outdated Packages","text":"Bash<pre><code>depkeeper check --outdated-only\n</code></pre>"},{"location":"getting-started/quickstart/#update-specific-packages","title":"Update Specific Packages","text":"Bash<pre><code>depkeeper update -p requests -p flask\n</code></pre>"},{"location":"getting-started/quickstart/#json-output-for-cicd","title":"JSON Output for CI/CD","text":"Bash<pre><code>depkeeper check --format json\n</code></pre>"},{"location":"getting-started/quickstart/#increase-verbosity","title":"Increase Verbosity","text":"Bash<pre><code>depkeeper -v check     # Info level\ndepkeeper -vv check    # Debug level\n</code></pre>"},{"location":"getting-started/quickstart/#quick-reference","title":"Quick Reference","text":"Text Only<pre><code>Command                            Description\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ndepkeeper check                    Check for available updates\ndepkeeper check --outdated-only    Show only outdated packages\ndepkeeper check -f json            Output as JSON\ndepkeeper update                   Update all packages\ndepkeeper update --dry-run         Preview updates without changes\ndepkeeper update -y                Update without confirmation\ndepkeeper update --backup          Create backup before updating\ndepkeeper update -p PKG            Update specific package(s)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage -- Learn more about checking and updating dependencies</li> <li>Configuration -- Customize depkeeper behavior</li> <li>CI/CD Integration -- Automate dependency updates in your pipeline</li> </ul>"},{"location":"guides/","title":"User Guide","text":"<p>Comprehensive guides covering all depkeeper features and common workflows.</p>"},{"location":"guides/#guides","title":"Guides","text":"<ul> <li> <p> Checking for Updates</p> <p>Master the <code>check</code> command with all its options and output formats.</p> <p> Learn more</p> </li> <li> <p> Updating Dependencies</p> <p>Safely update packages with backups, dry runs, and selective updates.</p> <p> Learn more</p> </li> <li> <p> Dependency Resolution</p> <p>Understand how depkeeper detects and resolves conflicts.</p> <p> Learn more</p> </li> <li> <p> CI/CD Integration</p> <p>Automate dependency checks in GitHub Actions, GitLab CI, and more.</p> <p> Learn more</p> </li> <li> <p> Configuration</p> <p>Customize depkeeper behavior via CLI options and environment variables.</p> <p> Learn more</p> </li> <li> <p> Best Practices</p> <p>Recommended practices for dependency management and update workflows.</p> <p> Learn more</p> </li> <li> <p> Troubleshooting</p> <p>Common issues and their solutions when using depkeeper.</p> <p> Learn more</p> </li> </ul>"},{"location":"guides/#common-workflows","title":"Common Workflows","text":""},{"location":"guides/#daily-development","title":"Daily Development","text":"Bash<pre><code># Morning: Check what's outdated\ndepkeeper check --outdated-only\n\n# When ready: Update safely\ndepkeeper update --backup -y\n</code></pre>"},{"location":"guides/#before-release","title":"Before Release","text":"Bash<pre><code># Full check with conflict resolution\ndepkeeper check\n\n# Preview updates\ndepkeeper update --dry-run\n\n# Apply after review\ndepkeeper update -y\n</code></pre>"},{"location":"guides/#cicd-pipeline","title":"CI/CD Pipeline","text":"Bash<pre><code># Exit non-zero if outdated (for CI notifications)\ndepkeeper check --format json --outdated-only\n\n# Automated update with backup\ndepkeeper update --backup -y\n</code></pre>"},{"location":"guides/#best-practices","title":"Best Practices","text":"<p>Version Pinning</p> <p>Always pin your direct dependencies to specific versions for reproducible builds: Text Only<pre><code>requests==2.31.0\nflask==2.3.3\n</code></pre></p> <p>Regular Updates</p> <p>Check for updates weekly or integrate into your CI/CD pipeline for automated notifications.</p> <p>Test After Updates</p> <p>Always run your test suite after updating dependencies: Bash<pre><code>depkeeper update -y &amp;&amp; pytest\n</code></pre></p> <p>Major Versions</p> <p>depkeeper won't cross major version boundaries automatically. When you're ready for a major upgrade, update manually and test thoroughly.</p>"},{"location":"guides/best-practices/","title":"Best Practices","text":"<p>This guide covers recommended practices for using depkeeper effectively in your Python projects.</p>"},{"location":"guides/best-practices/#dependency-management","title":"Dependency Management","text":""},{"location":"guides/best-practices/#pin-your-dependencies","title":"Pin Your Dependencies","text":"<p>Always pin exact versions in production:</p> Text Only<pre><code># Good -- predictable builds\nrequests==2.31.0\nflask==3.0.0\n\n# Avoid in production -- unpredictable\nrequests&gt;=2.28.0\nflask\n</code></pre>"},{"location":"guides/best-practices/#use-semantic-version-constraints","title":"Use Semantic Version Constraints","text":"<p>For libraries and development, use flexible constraints:</p> Text Only<pre><code># Allow patch updates (bug fixes)\nrequests~=2.31.0   # &gt;=2.31.0, &lt;2.32.0\n\n# Allow minor updates (features)\nrequests&gt;=2.31.0,&lt;3.0.0\n</code></pre>"},{"location":"guides/best-practices/#separate-dependency-files","title":"Separate Dependency Files","text":"<p>Organize dependencies by purpose:</p> Text Only<pre><code>requirements.txt          # Core production dependencies\nrequirements-dev.txt      # Development tools (pytest, black)\nrequirements-docs.txt     # Documentation (mkdocs, sphinx)\nrequirements-test.txt     # Test-specific packages\n</code></pre>"},{"location":"guides/best-practices/#update-workflow","title":"Update Workflow","text":""},{"location":"guides/best-practices/#regular-update-schedule","title":"Regular Update Schedule","text":"<ol> <li>Weekly -- Check for updates with <code>depkeeper check</code></li> <li>Monthly -- Apply patch updates</li> <li>Quarterly -- Evaluate minor/major updates</li> </ol>"},{"location":"guides/best-practices/#pre-update-checklist","title":"Pre-Update Checklist","text":"Bash<pre><code># 1. Ensure tests pass before updating\npytest\n\n# 2. Check available updates\ndepkeeper check --outdated-only\n\n# 3. Preview changes (dry run)\ndepkeeper update --dry-run\n\n# 4. Apply updates with backup\ndepkeeper update --backup -y\n\n# 5. Run tests again\npytest\n\n# 6. Commit changes\ngit commit -am \"chore: update dependencies\"\n</code></pre>"},{"location":"guides/best-practices/#handle-breaking-changes","title":"Handle Breaking Changes","text":"<p>For major version updates:</p> <ol> <li>Read the changelog thoroughly</li> <li>Update one package at a time</li> <li>Test after each update</li> <li>Document any migration steps</li> </ol>"},{"location":"guides/best-practices/#security","title":"Security","text":""},{"location":"guides/best-practices/#keep-dependencies-up-to-date","title":"Keep Dependencies Up to Date","text":"<p>Regular updates are your best defense against known vulnerabilities:</p> Bash<pre><code># Check for outdated packages weekly\ndepkeeper check --outdated-only\n\n# Use pip-audit or safety alongside depkeeper for vulnerability scanning\npip-audit\n</code></pre>"},{"location":"guides/best-practices/#address-vulnerabilities-promptly","title":"Address Vulnerabilities Promptly","text":"<ul> <li>Critical/High -- Fix within 24-48 hours</li> <li>Medium -- Fix within 1 week</li> <li>Low -- Fix within 1 month</li> </ul>"},{"location":"guides/best-practices/#keep-dependencies-minimal","title":"Keep Dependencies Minimal","text":"<p>Fewer dependencies mean a smaller attack surface:</p> <ul> <li>Review unused packages periodically</li> <li>Prefer standard library when possible</li> <li>Choose well-maintained packages</li> </ul>"},{"location":"guides/best-practices/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"guides/best-practices/#fail-early","title":"Fail Early","text":"YAML<pre><code># .github/workflows/deps.yml\n- name: Check for outdated dependencies\n  run: depkeeper check --outdated-only --format json\n</code></pre>"},{"location":"guides/best-practices/#automated-updates","title":"Automated Updates","text":"<p>Use Dependabot or Renovate alongside depkeeper for automated PRs. depkeeper works well as the update engine within CI pipelines:</p> Bash<pre><code># Automated update with backup\ndepkeeper update --backup -y\n</code></pre>"},{"location":"guides/best-practices/#pin-versions-for-reproducibility","title":"Pin Versions for Reproducibility","text":"<p>Use exact version pins in production and let depkeeper manage the update process:</p> Text Only<pre><code># requirements.txt -- pinned for reproducibility\nrequests==2.31.0\nflask==3.0.0\nclick==8.1.7\n</code></pre>"},{"location":"guides/best-practices/#code-review","title":"Code Review","text":""},{"location":"guides/best-practices/#dependency-change-reviews","title":"Dependency Change Reviews","text":"<p>When reviewing dependency updates:</p> <ol> <li>Check the version diff (patch/minor/major)</li> <li>Review the changelog</li> <li>Verify security implications</li> <li>Ensure tests pass</li> </ol>"},{"location":"guides/best-practices/#pr-description-template","title":"PR Description Template","text":"Markdown<pre><code>## Dependency Updates\n\n- `requests`: 2.28.0 \u2192 2.31.0 (minor)\n- `flask`: 2.3.0 \u2192 2.3.3 (patch)\n\n### Changelog Summary\n- requests: Added retry improvements, fixed SSL issue\n- flask: Security patch for XSS vulnerability\n\n### Testing\n- [x] Unit tests pass\n- [x] Integration tests pass\n- [x] Manual testing completed\n</code></pre>"},{"location":"guides/best-practices/#see-also","title":"See Also","text":"<ul> <li>Troubleshooting -- Common issues and solutions</li> <li>Configuration -- Customize depkeeper behavior</li> <li>CI/CD Integration -- Automate dependency management</li> </ul>"},{"location":"guides/checking-updates/","title":"Checking for Updates","text":"<p>The <code>check</code> command is your starting point for dependency management. It analyzes your requirements file and reports available updates without making any changes.</p>"},{"location":"guides/checking-updates/#basic-usage","title":"Basic Usage","text":"Bash<pre><code>depkeeper check\n</code></pre> <p>This reads <code>requirements.txt</code> from the current directory and reports on all packages.</p>"},{"location":"guides/checking-updates/#specifying-a-file","title":"Specifying a File","text":"<p>Check a specific requirements file:</p> Bash<pre><code>depkeeper check requirements-dev.txt\ndepkeeper check path/to/requirements.txt\n</code></pre>"},{"location":"guides/checking-updates/#output-formats","title":"Output Formats","text":""},{"location":"guides/checking-updates/#table-format-default","title":"Table Format (Default)","text":"<p>Beautiful, human-readable output:</p> Bash<pre><code>depkeeper check --format table\n</code></pre> Text Only<pre><code>                                    Dependency Status\n\n  Status       Package    Current   Latest   Recommended   Update Type   Conflicts   Python Support\n\n  \u2713 OK         django      3.2.0     5.0.2        -             -           -        Current: &gt;=3.8\n                                                                                     Latest: &gt;=3.10\n\n  \u2b06 OUTDATED   requests    2.28.0    2.32.0     2.32.0        minor         -        Current: &gt;=3.7\n                                                                                     Latest: &gt;=3.8\n\n  \u2b06 OUTDATED   flask       2.0.0     3.0.1      2.3.3         patch         -        Current: &gt;=3.7\n                                                                                     Latest: &gt;=3.8\n\n[WARNING] 2 package(s) have updates available\n</code></pre> <p>Columns explained:</p> Column Description Status Whether the package is up to date (<code>OK</code>) or <code>OUTDATED</code> Package Normalized package name Current Version from your requirements file Latest Newest version on PyPI Recommended Safe upgrade (within major version), or <code>-</code> if already up to date Update Type Severity of the update (<code>patch</code>, <code>minor</code>, or <code>major</code>) Conflicts Any dependency conflicts detected Python Support Required Python version for the current and latest releases"},{"location":"guides/checking-updates/#simple-format","title":"Simple Format","text":"<p>Compact, one-line-per-package output:</p> Bash<pre><code>depkeeper check --format simple\n</code></pre> Text Only<pre><code> requests             2.28.0     \u2192 2.32.0     (recommended: 2.32.0)\n       Python: installed: &gt;=3.7, latest: &gt;=3.8\n flask                2.0.0      \u2192 3.0.1      (recommended: 2.3.3)\n       Python: installed: &gt;=3.7, latest: &gt;=3.8, recommended: &gt;=3.7\n celery               5.3.0      \u2192 5.3.6\n       Python: installed: &gt;=3.8, latest: &gt;=3.8\n</code></pre> <p>Each line shows the package name, installed version, latest version, and a recommended version when it differs from the latest. The indented Python line shows the required Python version for each relevant release.</p>"},{"location":"guides/checking-updates/#json-format","title":"JSON Format","text":"<p>Machine-readable output for CI/CD:</p> Bash<pre><code>depkeeper check --format json\n</code></pre> JSON<pre><code>[\n  {\n    \"name\": \"requests\",\n    \"status\": \"latest\",\n    \"versions\": {\n      \"current\": \"2.32.5\",\n      \"latest\": \"2.32.5\",\n      \"recommended\": \"2.32.5\"\n    },\n    \"python_requirements\": {\n      \"current\": \"&gt;=3.9\",\n      \"latest\": \"&gt;=3.9\",\n      \"recommended\": \"&gt;=3.9\"\n    }\n  },\n  {\n    \"name\": \"polars\",\n    \"status\": \"outdated\",\n    \"versions\": {\n      \"current\": \"1.37.1\",\n      \"latest\": \"1.38.1\",\n      \"recommended\": \"1.38.1\"\n    },\n    \"update_type\": \"minor\",\n    \"python_requirements\": {\n      \"current\": \"&gt;=3.10\",\n      \"latest\": \"&gt;=3.10\",\n      \"recommended\": \"&gt;=3.10\"\n    }\n  },\n  {\n    \"name\": \"setuptools\",\n    \"status\": \"latest\",\n    \"versions\": {\n      \"current\": \"80.10.2\",\n      \"latest\": \"82.0.0\",\n      \"recommended\": \"80.10.2\"\n    },\n    \"python_requirements\": {\n      \"current\": \"&gt;=3.9\",\n      \"latest\": \"&gt;=3.9\",\n      \"recommended\": \"&gt;=3.9\"\n    }\n  }\n]\n</code></pre> <p>Each object includes the package <code>name</code>, its <code>status</code> (<code>latest</code> or <code>outdated</code>), a <code>versions</code> block with <code>current</code>, <code>latest</code>, and <code>recommended</code> versions, and a <code>python_requirements</code> block showing the required Python version for each release. Outdated packages also include an <code>update_type</code> field (<code>patch</code>, <code>minor</code>, or <code>major</code>).</p>"},{"location":"guides/checking-updates/#filtering-results","title":"Filtering Results","text":""},{"location":"guides/checking-updates/#outdated-packages-only","title":"Outdated Packages Only","text":"<p>Show only packages that have available updates:</p> Bash<pre><code>depkeeper check --outdated-only\n</code></pre> <p>This is useful when you have many dependencies and only want to see what needs attention.</p>"},{"location":"guides/checking-updates/#conflict-detection","title":"Conflict Detection","text":"<p>By default, depkeeper checks for dependency conflicts during version resolution.</p>"},{"location":"guides/checking-updates/#understanding-conflicts","title":"Understanding Conflicts","text":"<p>A conflict occurs when packages have incompatible version requirements:</p> Text Only<pre><code>                                         Dependency Status\n\n  Status       Package           Current   Latest   Recommended   Update Type   Conflicts                        Python Support\n\n  \u2b06 OUTDATED   pytest-asyncio     0.3.0     1.3.0     0.23.8        minor         -                             Latest: &gt;=3.10\n                                                                                                                Recommended: &gt;=3.8\n\n  \u2b06 OUTDATED   pytest             7.0.2     9.0.2     7.4.4         minor    pytest-asyncio needs &gt;= 7.0.0,&lt;9      Latest: &gt;=3.10\n                                                                                                                Recommended: &gt;=3.7\n\n[WARNING] 2 package(s) have updates available\n</code></pre> <p>In this example, <code>pytest</code> is constrained by <code>pytest-asyncio</code> which requires <code>pytest&gt;=8.2,&lt;9</code>. depkeeper detects this conflict and adjusts the recommended version of <code>pytest</code> to stay within safe boundaries.</p>"},{"location":"guides/checking-updates/#how-it-works","title":"How It Works","text":"<ol> <li>Metadata Fetch: depkeeper fetches dependency metadata from PyPI</li> <li>Graph Building: Builds a dependency graph for all packages</li> <li>Conflict Detection: Identifies version incompatibilities</li> <li>Resolution: Adjusts recommendations to resolve conflicts</li> </ol>"},{"location":"guides/checking-updates/#disabling-conflict-checking","title":"Disabling Conflict Checking","text":"<p>For faster checks without resolution:</p> Bash<pre><code>depkeeper check --no-check-conflicts\n</code></pre> <p>Warning</p> <p>Skipping conflict checking may result in recommendations that create broken environments.</p>"},{"location":"guides/checking-updates/#version-matching","title":"Version Matching","text":""},{"location":"guides/checking-updates/#default-behavior","title":"Default Behavior","text":"<p>By default, depkeeper infers the current version from version specifiers:</p> Text Only<pre><code># These are treated as \"current version = 2.0.0\"\nrequests&gt;=2.0.0\nrequests&gt;=2.0.0,&lt;3.0.0\n</code></pre>"},{"location":"guides/checking-updates/#strict-version-matching","title":"Strict Version Matching","text":"<p>Only consider exact pins (<code>==</code>) as the current version:</p> Bash<pre><code>depkeeper check --strict-version-matching\n</code></pre> <p>With this option:</p> Text Only<pre><code>requests&gt;=2.0.0           # Current: Unknown\nrequests==2.28.0          # Current: 2.28.0\n</code></pre>"},{"location":"guides/checking-updates/#verbosity-levels","title":"Verbosity Levels","text":"<p>Increase output detail for debugging:</p> Bash<pre><code># Info level - shows more context\ndepkeeper -v check\n\n# Debug level - shows HTTP requests, timing, etc.\ndepkeeper -vv check\n</code></pre>"},{"location":"guides/checking-updates/#color-output","title":"Color Output","text":"<p>Control colored output:</p> Bash<pre><code># Disable colors (for CI logs)\ndepkeeper --no-color check\n\n# Force colors (default)\ndepkeeper --color check\n</code></pre> <p>Or via environment variable:</p> Bash<pre><code>export DEPKEEPER_COLOR=false\ndepkeeper check\n</code></pre>"},{"location":"guides/checking-updates/#examples","title":"Examples","text":""},{"location":"guides/checking-updates/#daily-status-check","title":"Daily Status Check","text":"Bash<pre><code>depkeeper check --outdated-only\n</code></pre>"},{"location":"guides/checking-updates/#cicd-pipeline","title":"CI/CD Pipeline","text":"Bash<pre><code># JSON output, check for issues\ndepkeeper check --format json &gt; deps-report.json\n</code></pre>"},{"location":"guides/checking-updates/#quick-overview","title":"Quick Overview","text":"Bash<pre><code>depkeeper check --format simple --outdated-only\n</code></pre>"},{"location":"guides/checking-updates/#debugging-issues","title":"Debugging Issues","text":"Bash<pre><code>depkeeper -vv check\n</code></pre>"},{"location":"guides/checking-updates/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> Success (even if updates available) <code>1</code> Error (parse failure, network issue) <code>2</code> Usage error (invalid arguments)"},{"location":"guides/checking-updates/#next-steps","title":"Next Steps","text":"<ul> <li>Updating Dependencies -- Apply the recommended updates</li> <li>Dependency Resolution -- Understand conflict handling</li> <li>CLI Reference -- Complete command documentation</li> </ul>"},{"location":"guides/ci-cd-integration/","title":"CI/CD Integration","text":"<p>Integrate depkeeper into your CI/CD pipeline for automated dependency monitoring and updates.</p>"},{"location":"guides/ci-cd-integration/#overview","title":"Overview","text":"<p>depkeeper fits into CI/CD workflows for:</p> <ul> <li>Monitoring: Alert when dependencies are outdated</li> <li>Reporting: Generate dependency reports</li> <li>Automation: Automatically update dependencies</li> <li>Security: Flag vulnerable packages (coming soon)</li> </ul> <p>Important</p> <p>The examples use <code>src/requirements.txt</code> -- replace with your actual requirements file path.</p>"},{"location":"guides/ci-cd-integration/#github-actions","title":"GitHub Actions","text":""},{"location":"guides/ci-cd-integration/#check-for-outdated-dependencies","title":"Check for Outdated Dependencies","text":"<p>Create <code>.github/workflows/dependency-check.yml</code>:</p> YAML<pre><code>name: Dependency Check\n\non:\n  schedule:\n    # Run every Monday at 9 AM UTC\n    - cron: '0 9 * * 1'\n  workflow_dispatch:  # Manual trigger\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Install depkeeper\n        run: pip install depkeeper\n\n      - name: Check dependencies and report\n        run: |\n          echo \"Checking for outdated dependencies:\"\n          depkeeper check src/requirements.txt --outdated-only --format table\n\n          # Fail if outdated dependencies are found\n          if depkeeper check src/requirements.txt --outdated-only --format json 2&gt;/dev/null | grep -q '\"status\": \"outdated\"'; then\n            echo \"\"\n            echo \"\u274c Build failed: Outdated dependencies detected. Please update them.\"\n            exit 1\n          fi\n</code></pre>"},{"location":"guides/ci-cd-integration/#automated-dependency-updates","title":"Automated Dependency Updates","text":"<p>Create <code>.github/workflows/dependency-update.yml</code>:</p> YAML<pre><code>name: Dependency Update\n\non:\n  schedule:\n    - cron: '0 9 * * 1'  # Weekly on Monday\n  workflow_dispatch:\n\njobs:\n  update:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: '3.11'\n\n      - name: Install dependencies\n        run: |\n          sudo apt-get update &amp;&amp; sudo apt-get install -y jq\n          pip install depkeeper\n          pip install -r src/requirements.txt\n\n      - name: Check for updates\n        id: check\n        run: |\n          depkeeper check src/requirements.txt --outdated-only --format json &gt; outdated.json\n          echo \"count=$(cat outdated.json | jq length)\" &gt;&gt; $GITHUB_OUTPUT\n\n      - name: Update dependencies\n        if: steps.check.outputs.count &gt; 0\n        run: depkeeper update src/requirements.txt -y\n\n      - name: Run tests\n        if: steps.check.outputs.count &gt; 0\n        run: |\n          cd src\n          pytest\n\n      - name: Generate update report\n        if: steps.check.outputs.count &gt; 0\n        run: |\n          echo \"UPDATES_LIST&lt;&lt;EOF\" &gt;&gt; $GITHUB_ENV\n          cat outdated.json | jq -r '.[] | \"- **\\(.name)**: \\(.versions.current) \u2192 \\(.versions.recommended)\"'\n          echo \"EOF\" &gt;&gt; $GITHUB_ENV\n\n      - name: Commit and push changes\n        if: steps.check.outputs.count &gt; 0\n        run: |\n          git config --global user.name \"github-actions[bot]\"\n          git config --global user.email \"github-actions[bot]@users.noreply.github.com\"\n          git checkout -b deps/automated-updates\n          git add src/requirements.txt\n          git commit -m \"chore(deps): update dependencies\"\n          git push -f origin deps/automated-updates\n\n      - name: Create Pull Request\n        if: steps.check.outputs.count &gt; 0\n        uses: actions/github-script@v7\n        with:\n          script: |\n            const { data: pulls } = await github.rest.pulls.list({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              head: `${context.repo.owner}:deps/automated-updates`,\n              state: 'open'\n            });\n\n            const prBody = `Automated dependency updates by depkeeper.\n\n            ## Updated packages\n            ${process.env.UPDATES_LIST}`;\n\n            if (pulls.length === 0) {\n              await github.rest.pulls.create({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                title: '\u2b06\ufe0f Update dependencies',\n                head: 'deps/automated-updates',\n                base: 'master',\n                body: prBody\n              });\n            } else {\n              await github.rest.pulls.update({\n                owner: context.repo.owner,\n                repo: context.repo.repo,\n                pull_number: pulls[0].number,\n                body: prBody\n              });\n            }\n</code></pre>"},{"location":"guides/ci-cd-integration/#gitlab-ci","title":"GitLab CI","text":""},{"location":"guides/ci-cd-integration/#gitlab-ciyml","title":"<code>.gitlab-ci.yml</code>","text":"YAML<pre><code>stages:\n  - check\n  - update\n\nvariables:\n  PYTHON_VERSION: \"3.11\"\n\ndependency-check:\n  stage: check\n  image: python:${PYTHON_VERSION}\n  script:\n    - pip install depkeeper\n    - depkeeper check src/requirements.txt --outdated-only --format json &gt; deps-report.json || true\n    - depkeeper check src/requirements.txt --outdated-only --format table || true\n  artifacts:\n    paths:\n      - deps-report.json\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"\n    - if: $CI_PIPELINE_SOURCE == \"web\"\n\ndependency-update:\n  stage: update\n  dependencies: [dependency-check]\n  image: python:${PYTHON_VERSION}\n  script:\n    - pip install depkeeper pytest\n    - |\n      COUNT=$(python -c \"import json,sys; data=open('deps-report.json').read().strip(); print(len(json.loads(data)) if data else 0)\" 2&gt;/dev/null || echo \"0\")\n      if [ \"$COUNT\" -eq 0 ]; then\n        echo \"No outdated dependencies. Skipping update.\"\n        exit 0\n      fi\n    - depkeeper update src/requirements.txt --backup -y\n    - pip install -r src/requirements.txt\n    - cd src &amp;&amp; pytest\n  artifacts:\n    paths:\n      - src/requirements.txt\n      - src/requirements.txt.backup.*\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"schedule\"\n      when: manual\n    - if: $CI_PIPELINE_SOURCE == \"web\"\n      when: manual\n</code></pre>"},{"location":"guides/ci-cd-integration/#azure-pipelines","title":"Azure Pipelines","text":""},{"location":"guides/ci-cd-integration/#azure-pipelinesyml","title":"<code>azure-pipelines.yml</code>","text":"YAML<pre><code>trigger: none\n\nschedules:\n  - cron: '0 9 * * 1'\n    displayName: Weekly dependency check\n    branches:\n      include:\n        - main\n\npool:\n  vmImage: 'ubuntu-latest'\n\nsteps:\n  - task: UsePythonVersion@0\n    inputs:\n      versionSpec: '3.11'\n\n  - script: pip install depkeeper\n    displayName: Install depkeeper\n\n  - script: |\n      depkeeper check src/requirements.txt --outdated-only --format json \\\n        &gt; $(Build.ArtifactStagingDirectory)/deps.json || true\n    displayName: Check dependencies (JSON report)\n\n  - script: |\n      depkeeper check src/requirements.txt --outdated-only --format table || true\n    displayName: Show outdated packages\n\n  - task: PublishBuildArtifacts@1\n    condition: always()\n    inputs:\n      pathToPublish: '$(Build.ArtifactStagingDirectory)'\n      artifactName: dependency-report\n</code></pre>"},{"location":"guides/ci-cd-integration/#jenkins","title":"Jenkins","text":""},{"location":"guides/ci-cd-integration/#jenkinsfile","title":"<code>Jenkinsfile</code>","text":"Groovy<pre><code>pipeline {\n    agent {\n        docker {\n            image 'python:3.11'\n        }\n    }\n\n    triggers {\n        cron('H 9 * * 1')  // Weekly on Monday\n    }\n\n    stages {\n        stage('Setup') {\n            steps {\n                sh 'apt-get update &amp;&amp; apt-get install -y jq'\n                sh 'pip install depkeeper'\n            }\n        }\n\n        stage('Check Dependencies') {\n            steps {\n                sh '''\n                    depkeeper check src/requirements.txt --outdated-only --format json \\\n                        &gt; deps-report.json || echo \"[]\" &gt; deps-report.json\n                '''\n                sh 'depkeeper check src/requirements.txt --outdated-only --format table || true'\n            }\n        }\n\n        stage('Archive Report') {\n            steps {\n                archiveArtifacts allowEmptyArchive: true, artifacts: 'deps-report.json'\n            }\n        }\n    }\n\n    post {\n        always {\n            script {\n                if (fileExists('deps-report.json')) {\n                    def outdated = sh(\n                        script: 'jq length deps-report.json || echo 0',\n                        returnStdout: true\n                    ).trim()\n\n                    if (outdated.toInteger() &gt; 0) {\n                        currentBuild.description = \"\u26a0\ufe0f ${outdated} outdated dependencies\"\n                    }\n                } else {\n                    echo \"deps-report.json not found \u2014 skipping outdated count.\"\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"guides/ci-cd-integration/#circleci","title":"CircleCI","text":""},{"location":"guides/ci-cd-integration/#circleciconfigyml","title":"<code>.circleci/config.yml</code>","text":"YAML<pre><code>version: 2.1\n\njobs:\n  dependency-check:\n    docker:\n      - image: cimg/python:3.11\n    steps:\n      - checkout\n      - run:\n          name: Install depkeeper\n          command: pip install depkeeper\n      - run:\n          name: Export outdated deps as JSON\n          command: depkeeper check src/requirements.txt --outdated-only --format json &gt; deps-report.json || true\n      - run:\n          name: Show outdated deps as table\n          command: depkeeper check src/requirements.txt --outdated-only --format table || true\n      - store_artifacts:\n          path: deps-report.json\n          destination: deps-report.json\n\nworkflows:\n  weekly-check:\n    triggers:\n      - schedule:\n          cron: \"0 9 * * 1\"\n          filters:\n            branches:\n              only:\n                - main\n    jobs:\n      - dependency-check\n</code></pre>"},{"location":"guides/ci-cd-integration/#pre-commit-hook","title":"Pre-commit Hook","text":"<p>Add to <code>.pre-commit-config.yaml</code>:</p> YAML<pre><code>repos:\n  - repo: local\n    hooks:\n      - id: depkeeper-check\n        name: Check dependencies\n        entry: depkeeper check src/requirements.txt --outdated-only --format table\n        language: system\n        pass_filenames: false\n        files: requirements\\.txt$\n</code></pre>"},{"location":"guides/ci-cd-integration/#best-practices","title":"Best Practices","text":""},{"location":"guides/ci-cd-integration/#1-weekly-checks","title":"1. Weekly Checks","text":"<p>Schedule dependency checks weekly to stay informed without noise:</p> YAML<pre><code>schedule:\n  - cron: '0 9 * * 1'  # Monday 9 AM\n</code></pre>"},{"location":"guides/ci-cd-integration/#2-separate-check-and-update","title":"2. Separate Check and Update","text":"<p>Keep check and update as separate jobs:</p> <ul> <li>Check: Always runs, reports status</li> <li>Update: Manual trigger or conditional</li> </ul>"},{"location":"guides/ci-cd-integration/#3-test-after-updates","title":"3. Test After Updates","text":"<p>Always run your test suite after automated updates:</p> YAML<pre><code>- name: Update\n  run: depkeeper update src/requirements.txt -y\n\n- name: Install updated packages\n  run: pip install -r src/requirements.txt\n\n- name: Test\n  run: pytest\n</code></pre>"},{"location":"guides/ci-cd-integration/#4-create-pull-requests","title":"4. Create Pull Requests","text":"<p>Don't push directly to main. Create PRs for review:</p> YAML<pre><code>- name: Commit and push changes\n  run: |\n    git config --global user.name \"github-actions[bot]\"\n    git config --global user.email \"github-actions[bot]@users.noreply.github.com\"\n    git checkout -b deps/automated-updates\n    git add src/requirements.txt\n    git commit -m \"chore(deps): update dependencies\"\n    git push -f origin deps/automated-updates\n\n- name: Create Pull Request\n  uses: actions/github-script@v7\n  with:\n    script: |\n      const { data: pulls } = await github.rest.pulls.list({\n        owner: context.repo.owner,\n        repo: context.repo.repo,\n        head: `${context.repo.owner}:deps/automated-updates`,\n        state: 'open'\n      });\n\n      if (pulls.length === 0) {\n        await github.rest.pulls.create({\n          owner: context.repo.owner,\n          repo: context.repo.repo,\n          title: '\u2b06\ufe0f Update dependencies',\n          head: 'deps/automated-updates',\n          base: 'master',\n          body: 'Automated dependency updates by depkeeper.'\n        });\n      }\n</code></pre>"},{"location":"guides/ci-cd-integration/#exit-codes","title":"Exit Codes","text":"<p>Use exit codes for CI logic:</p> Code Meaning CI Action <code>0</code> Success Continue <code>1</code> Error Fail build <code>2</code> Usage error Fail build"},{"location":"guides/ci-cd-integration/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration -- Customize depkeeper behavior</li> <li>CLI Reference -- All command options</li> <li>Exit Codes -- Complete exit code reference</li> </ul>"},{"location":"guides/configuration/","title":"Configuration","text":"<p>depkeeper can be configured through CLI options, environment variables, and configuration files. When a CLI flag is not explicitly provided, depkeeper reads the value from the configuration file. If no configuration file is found, built-in defaults apply.</p>"},{"location":"guides/configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>Configuration is applied in this order (later overrides earlier):</p> <ol> <li>Built-in defaults</li> <li>Configuration file (<code>depkeeper.toml</code> or <code>pyproject.toml</code>)</li> <li>Environment variables (<code>DEPKEEPER_*</code>)</li> <li>CLI arguments</li> </ol>"},{"location":"guides/configuration/#cli-options","title":"CLI Options","text":""},{"location":"guides/configuration/#global-options","title":"Global Options","text":"<p>These options apply to all commands:</p> Option Description Default <code>-c, --config PATH</code> Path to configuration file Auto-detected <code>-v, --verbose</code> Increase verbosity (can repeat: <code>-v</code>, <code>-vv</code>) Warning level <code>--color / --no-color</code> Enable/disable colored output <code>--color</code> <code>--version</code> Show version and exit -- <code>-h, --help</code> Show help and exit --"},{"location":"guides/configuration/#command-specific-options","title":"Command-Specific Options","text":"<p>See CLI Reference for complete option documentation per command.</p>"},{"location":"guides/configuration/#environment-variables","title":"Environment Variables","text":"<p>All environment variables are prefixed with <code>DEPKEEPER_</code>:</p> Variable Description Example <code>DEPKEEPER_CONFIG</code> Path to configuration file <code>/path/to/config.toml</code> <code>DEPKEEPER_COLOR</code> Enable/disable colors <code>true</code>, <code>false</code>"},{"location":"guides/configuration/#examples","title":"Examples","text":"Bash<pre><code># Disable colors\nexport DEPKEEPER_COLOR=false\ndepkeeper check\n</code></pre>"},{"location":"guides/configuration/#in-cicd","title":"In CI/CD","text":"YAML<pre><code>env:\n  DEPKEEPER_COLOR: false\n\nsteps:\n  - run: depkeeper check\n</code></pre>"},{"location":"guides/configuration/#configuration-file","title":"Configuration File","text":""},{"location":"guides/configuration/#file-locations","title":"File Locations","text":"<p>depkeeper looks for configuration in:</p> <ol> <li>Path specified by <code>--config</code> or <code>DEPKEEPER_CONFIG</code></li> <li><code>depkeeper.toml</code> in the current directory</li> <li><code>pyproject.toml</code> under <code>[tool.depkeeper]</code></li> </ol>"},{"location":"guides/configuration/#depkeepertoml-format","title":"depkeeper.toml Format","text":"TOML<pre><code># depkeeper.toml\n\n[depkeeper]\n# Enable conflict checking by default\ncheck_conflicts = true\n\n# Only consider exact version pins (==)\nstrict_version_matching = false\n</code></pre>"},{"location":"guides/configuration/#pyprojecttoml-format","title":"pyproject.toml Format","text":"TOML<pre><code># pyproject.toml\n\n[tool.depkeeper]\ncheck_conflicts = true\nstrict_version_matching = false\n</code></pre>"},{"location":"guides/configuration/#configuration-options-reference","title":"Configuration Options Reference","text":"Option Type Default Description <code>check_conflicts</code> bool <code>true</code> Enable dependency conflict resolution <code>strict_version_matching</code> bool <code>false</code> Only consider exact version pins (<code>==</code>)"},{"location":"guides/configuration/#excluding-packages","title":"Excluding Packages","text":"<p>Use the <code>--packages</code> / <code>-p</code> CLI option to update only specific packages:</p> Bash<pre><code># Update only specific packages\ndepkeeper update -p requests -p flask\n</code></pre>"},{"location":"guides/configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"guides/configuration/#conservative-production","title":"Conservative Production","text":"TOML<pre><code># depkeeper.toml - Production-safe settings\n\n[depkeeper]\ncheck_conflicts = true\nstrict_version_matching = true\n</code></pre>"},{"location":"guides/configuration/#active-development","title":"Active Development","text":"TOML<pre><code># depkeeper.toml - Development settings\n\n[depkeeper]\ncheck_conflicts = true\nstrict_version_matching = false\n</code></pre>"},{"location":"guides/configuration/#precedence-example","title":"Precedence Example","text":"<p>Given:</p> <p>depkeeper.toml: TOML<pre><code>[depkeeper]\ncheck_conflicts = true\n</code></pre></p> <p>Environment: Bash<pre><code>export DEPKEEPER_COLOR=false\n</code></pre></p> <p>Command: Bash<pre><code>depkeeper check --no-check-conflicts\n</code></pre></p> <p>The effective configuration is:</p> <ul> <li><code>check_conflicts = false</code> (CLI overrides file)</li> <li><code>color = false</code> (from environment)</li> </ul>"},{"location":"guides/configuration/#debugging-configuration","title":"Debugging Configuration","text":"<p>View effective configuration with verbose mode:</p> Bash<pre><code>depkeeper -vv check 2&gt;&amp;1 | grep -i config\n</code></pre> Text Only<pre><code>DEBUG: Config path: /project/depkeeper.toml\nDEBUG: Loaded configuration: {'check_conflicts': True, 'strict_version_matching': False}\nDEBUG: Effective check_conflicts: True\n</code></pre>"},{"location":"guides/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Reference -- Complete command documentation</li> <li>Configuration Options -- Full options reference</li> <li>CI/CD Integration -- Use configuration in pipelines</li> </ul>"},{"location":"guides/dependency-resolution/","title":"Dependency Resolution","text":"<p>depkeeper automatically detects and resolves dependency conflicts to ensure your environment stays working.</p>"},{"location":"guides/dependency-resolution/#what-are-dependency-conflicts","title":"What Are Dependency Conflicts?","text":"<p>A dependency conflict occurs when two packages require incompatible versions of the same dependency.</p>"},{"location":"guides/dependency-resolution/#example","title":"Example","text":"Text Only<pre><code># Your requirements.txt\nrequests==2.31.0\nboto3==1.34.0\n</code></pre> <p>Both packages depend on <code>urllib3</code>:</p> <ul> <li><code>requests</code> requires <code>urllib3&gt;=1.21.1,&lt;3</code></li> <li><code>boto3</code> (via <code>botocore</code>) requires <code>urllib3&gt;=1.25.4,!=2.2.0,&lt;3</code></li> </ul> <p>These are compatible. But consider:</p> Text Only<pre><code>package-a requires foo&gt;=2.0.0\npackage-b requires foo&lt;2.0.0\n</code></pre> <p>This is a conflict -- no version of <code>foo</code> satisfies both requirements.</p>"},{"location":"guides/dependency-resolution/#how-depkeeper-resolves-conflicts","title":"How depkeeper Resolves Conflicts","text":""},{"location":"guides/dependency-resolution/#resolution-algorithm","title":"Resolution Algorithm","text":"<ol> <li>Fetch Metadata: Download dependency information from PyPI</li> <li>Build Graph: Create a dependency graph of all packages</li> <li>Identify Conflicts: Find version incompatibilities</li> <li>Adjust Recommendations: Use downgrading or constraining to resolve</li> </ol>"},{"location":"guides/dependency-resolution/#resolution-strategies","title":"Resolution Strategies","text":"Status Meaning <code>KEPT_RECOMMENDED</code> Original recommendation was conflict-free <code>UPGRADED</code> Successfully upgraded to a newer version <code>DOWNGRADED</code> Had to use an older version due to conflicts <code>CONSTRAINED</code> Version was limited by another package <code>KEPT_CURRENT</code> No safe upgrade found; stayed at current"},{"location":"guides/dependency-resolution/#viewing-conflict-information","title":"Viewing Conflict Information","text":""},{"location":"guides/dependency-resolution/#in-check-output","title":"In Check Output","text":"Bash<pre><code>depkeeper check\n</code></pre> Text Only<pre><code>Package       Current    Recommended  Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nrequests      2.28.0     2.31.0       Outdated (minor)\nurllib3       1.26.0     1.26.18      Constrained\n\n\u26a0 Dependency Constraints:\n  urllib3 constrained by:\n    - requests (requires urllib3&gt;=1.21.1,&lt;2)\n</code></pre>"},{"location":"guides/dependency-resolution/#in-json-output","title":"In JSON Output","text":"Bash<pre><code>depkeeper check --format json\n</code></pre> JSON<pre><code>{\n  \"name\": \"urllib3\",\n  \"current_version\": \"1.26.0\",\n  \"recommended_version\": \"1.26.18\",\n  \"has_conflicts\": false,\n  \"conflicts\": [],\n  \"constrained_by\": [\"requests\"]\n}\n</code></pre>"},{"location":"guides/dependency-resolution/#major-version-boundaries","title":"Major Version Boundaries","text":"<p>depkeeper enforces strict major version boundaries during resolution.</p>"},{"location":"guides/dependency-resolution/#why","title":"Why?","text":"<p>Major versions often include:</p> <ul> <li>Breaking API changes</li> <li>Removed functionality</li> <li>Incompatible dependencies</li> </ul>"},{"location":"guides/dependency-resolution/#how-it-works","title":"How It Works","text":"Text Only<pre><code>Package       Current    Latest     Recommended\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nflask         2.0.0      3.0.1      2.3.3\n</code></pre> <p>Even though <code>flask 3.0.1</code> is available, depkeeper recommends <code>2.3.3</code> because:</p> <ol> <li>Your current version is <code>2.0.0</code> (major version 2)</li> <li>Latest in major version 2 is <code>2.3.3</code></li> <li><code>3.0.1</code> would cross the major version boundary</li> </ol>"},{"location":"guides/dependency-resolution/#intentional-major-upgrades","title":"Intentional Major Upgrades","text":"<p>When you're ready for a major upgrade:</p> <ol> <li> <p>Update your requirements file manually:    Text Only<pre><code>flask&gt;=3.0.0\n</code></pre></p> </li> <li> <p>Run depkeeper to resolve dependencies:    Bash<pre><code>depkeeper update\n</code></pre></p> </li> <li> <p>Test thoroughly</p> </li> </ol>"},{"location":"guides/dependency-resolution/#conflict-scenarios","title":"Conflict Scenarios","text":""},{"location":"guides/dependency-resolution/#scenario-1-transitive-conflict","title":"Scenario 1: Transitive Conflict","text":"Text Only<pre><code># Your requirements\nrequests==2.31.0\nsome-package==1.0.0  # requires urllib3&gt;=2.0.0\n</code></pre> <p><code>requests</code> requires <code>urllib3&lt;3</code> but works with 2.x. <code>some-package</code> requires <code>urllib3&gt;=2.0.0</code>.</p> <p>Resolution: Update <code>urllib3</code> to <code>2.x</code> to satisfy both.</p>"},{"location":"guides/dependency-resolution/#scenario-2-irreconcilable-conflict","title":"Scenario 2: Irreconcilable Conflict","text":"Text Only<pre><code>package-a requires foo&gt;=2.0.0,&lt;3.0.0\npackage-b requires foo&gt;=3.0.0\n</code></pre> <p>No version of <code>foo</code> can satisfy both.</p> <p>Resolution: depkeeper reports the conflict and keeps the current version or suggests alternatives.</p>"},{"location":"guides/dependency-resolution/#scenario-3-diamond-dependency","title":"Scenario 3: Diamond Dependency","text":"Text Only<pre><code>    A\n   / \\\n  B   C\n   \\ /\n    D (different versions required)\n</code></pre> <p><code>A</code> depends on <code>B</code> and <code>C</code>, which both depend on <code>D</code> but require different versions.</p> <p>Resolution: depkeeper finds a version of <code>D</code> that satisfies both or reports if impossible.</p>"},{"location":"guides/dependency-resolution/#controlling-conflict-resolution","title":"Controlling Conflict Resolution","text":""},{"location":"guides/dependency-resolution/#enabledisable","title":"Enable/Disable","text":"Bash<pre><code># Enabled by default\ndepkeeper check --check-conflicts\ndepkeeper update --check-conflicts\n\n# Disable for faster but potentially unsafe checks\ndepkeeper check --no-check-conflicts\ndepkeeper update --no-check-conflicts\n</code></pre>"},{"location":"guides/dependency-resolution/#when-to-disable","title":"When to Disable","text":"<ul> <li>Quick status checks</li> <li>When you know your environment is compatible</li> <li>Performance-critical CI pipelines (but use carefully)</li> </ul> <p>Warning</p> <p>Disabling conflict checking may result in recommendations that break your environment.</p>"},{"location":"guides/dependency-resolution/#resolution-details","title":"Resolution Details","text":""},{"location":"guides/dependency-resolution/#verbose-output","title":"Verbose Output","text":"<p>For detailed resolution information:</p> Bash<pre><code>depkeeper -vv check\n</code></pre> Text Only<pre><code>DEBUG: Fetching metadata for requests...\nDEBUG: Fetching metadata for urllib3...\nDEBUG: Building dependency graph...\nDEBUG: Checking constraints for urllib3:\n  - requests requires: urllib3&gt;=1.21.1,&lt;3\nDEBUG: Finding compatible version for urllib3 within 1.x...\nDEBUG: Selected urllib3==1.26.18 (satisfies all constraints)\n</code></pre>"},{"location":"guides/dependency-resolution/#resolution-result","title":"Resolution Result","text":"<p>In JSON output, each package includes resolution details:</p> JSON<pre><code>{\n  \"name\": \"urllib3\",\n  \"resolution_status\": \"CONSTRAINED\",\n  \"resolution_reason\": \"Version constrained by requests dependency\",\n  \"constraints\": [\n    {\n      \"package\": \"requests\",\n      \"specifier\": \"&gt;=1.21.1,&lt;3\"\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/dependency-resolution/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/dependency-resolution/#no-compatible-version-found","title":"\"No compatible version found\"","text":"<p>This means no version satisfies all constraints.</p> <p>Solutions:</p> <ol> <li>Check if packages are compatible at all</li> <li>Consider updating one package manually</li> <li>Look for alternative packages</li> </ol>"},{"location":"guides/dependency-resolution/#circular-dependency-detected","title":"\"Circular dependency detected\"","text":"<p>Packages depend on each other in a cycle.</p> <p>Solutions:</p> <ol> <li>This is usually handled automatically</li> <li>If issues persist, check package documentation</li> </ol>"},{"location":"guides/dependency-resolution/#resolution-takes-too-long","title":"Resolution takes too long","text":"<p>Solutions:</p> <ol> <li>Use <code>--no-check-conflicts</code> for quick checks</li> <li>Reduce the number of packages being checked</li> <li>Check network connectivity (PyPI fetches)</li> </ol>"},{"location":"guides/dependency-resolution/#best-practices","title":"Best Practices","text":"<p>Pin Direct Dependencies</p> <p>Pin your direct dependencies to specific versions. Let depkeeper handle the resolution.</p> <p>Regular Updates</p> <p>Update frequently to avoid large version jumps that create conflicts.</p> <p>Test After Updates</p> <p>Always run your test suite after updates to catch compatibility issues.</p> <p>Review Constraints</p> <p>When a package is constrained, review if the constraining package can be updated first.</p>"},{"location":"guides/dependency-resolution/#next-steps","title":"Next Steps","text":"<ul> <li>CI/CD Integration -- Automate dependency management</li> <li>CLI Reference -- Complete command documentation</li> <li>Configuration -- Customize behavior</li> </ul>"},{"location":"guides/troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and their solutions when using depkeeper.</p>"},{"location":"guides/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"guides/troubleshooting/#pip-install-fails","title":"pip install fails","text":"<p>Error: <code>Could not find a version that satisfies the requirement</code></p> <p>Solution: Bash<pre><code># Upgrade pip first\npip install --upgrade pip\n\n# Try installing again\npip install depkeeper\n</code></pre></p>"},{"location":"guides/troubleshooting/#command-not-found","title":"Command not found","text":"<p>Error: <code>depkeeper: command not found</code></p> <p>Solution: Bash<pre><code># Ensure pip scripts are in PATH\n# For Unix/macOS:\nexport PATH=\"$HOME/.local/bin:$PATH\"\n\n# For Windows (PowerShell):\n$env:PATH += \";$env:APPDATA\\Python\\Scripts\"\n\n# Or run as a module:\npython -m depkeeper --help\n</code></pre></p>"},{"location":"guides/troubleshooting/#parsing-errors","title":"Parsing Errors","text":""},{"location":"guides/troubleshooting/#invalid-requirements-file","title":"Invalid requirements file","text":"<p>Error: <code>ParseError: Invalid requirement at line X</code></p> <p>Common causes:</p> <ul> <li>Missing version specifier</li> <li>Invalid characters in package name</li> <li>Malformed URL</li> </ul> <p>Solution: Bash<pre><code># Validate your requirements file\npip install -r requirements.txt --dry-run\n\n# Fix the problematic line and try again\n</code></pre></p>"},{"location":"guides/troubleshooting/#encoding-issues","title":"Encoding issues","text":"<p>Error: <code>UnicodeDecodeError: 'utf-8' codec can't decode</code></p> <p>Solution: Bash<pre><code># Convert file to UTF-8\n# On Unix/macOS:\niconv -f ISO-8859-1 -t UTF-8 requirements.txt &gt; requirements_utf8.txt\n\n# On Windows (PowerShell):\nGet-Content requirements.txt | Set-Content -Encoding UTF8 requirements_utf8.txt\n</code></pre></p>"},{"location":"guides/troubleshooting/#network-issues","title":"Network Issues","text":""},{"location":"guides/troubleshooting/#connection-timeout","title":"Connection timeout","text":"<p>Error: <code>NetworkError: Connection to pypi.org timed out</code></p> <p>Solutions: Bash<pre><code># Check network connectivity\nping pypi.org\n\n# If behind a firewall, ensure pypi.org is accessible\ncurl -I https://pypi.org\n</code></pre></p>"},{"location":"guides/troubleshooting/#ssl-certificate-errors","title":"SSL certificate errors","text":"<p>Error: <code>SSLError: certificate verify failed</code></p> <p>Solutions: Bash<pre><code># Update certificates\npip install --upgrade certifi\n\n# For corporate proxies, configure CA bundle\nexport REQUESTS_CA_BUNDLE=/path/to/ca-bundle.crt\n</code></pre></p>"},{"location":"guides/troubleshooting/#behind-a-proxy","title":"Behind a proxy","text":"<p>Solution: Bash<pre><code># Set proxy environment variables\nexport HTTP_PROXY=http://proxy.example.com:8080\nexport HTTPS_PROXY=http://proxy.example.com:8080\n\n# Or configure in pip\npip config set global.proxy http://proxy.example.com:8080\n</code></pre></p>"},{"location":"guides/troubleshooting/#dependency-resolution","title":"Dependency Resolution","text":""},{"location":"guides/troubleshooting/#conflict-detected","title":"Conflict detected","text":"<p>Warning: Dependency conflicts shown in check output</p> <p>Example: <code>package-a requires package-b&lt;2.0, but package-c requires package-b&gt;=2.0</code></p> <p>Solutions:</p> <ol> <li> <p>Check current state: Bash<pre><code>depkeeper check --format json\npip list\n</code></pre></p> </li> <li> <p>Find the conflict source: Bash<pre><code>pip show package-a package-c\n</code></pre></p> </li> <li> <p>Try updating related packages: Bash<pre><code>depkeeper update -p package-a -p package-c\n</code></pre></p> </li> <li> <p>Use constraints: Text Only<pre><code># Add constraint to requirements.txt\npackage-b&gt;=1.5,&lt;2.0  # Find common version\n</code></pre></p> </li> <li> <p>As last resort, pin the conflicting package: Text Only<pre><code># requirements.txt\npackage-b==1.9.0  # Known working version\n</code></pre></p> </li> </ol>"},{"location":"guides/troubleshooting/#circular-dependencies","title":"Circular dependencies","text":"<p>Warning: <code>Circular dependency detected: A -&gt; B -&gt; A</code></p> <p>Solution: This is usually not an issue, but if causing problems:</p> Bash<pre><code># Install in specific order\npip install package-b\npip install package-a\n</code></pre>"},{"location":"guides/troubleshooting/#update-issues","title":"Update Issues","text":""},{"location":"guides/troubleshooting/#update-fails-with-error","title":"Update fails with error","text":"<p>Error: <code>FileOperationError: Cannot write to requirements.txt</code></p> <p>Common causes:</p> <ul> <li>Write permission denied</li> <li>File locked by another process</li> <li>Disk full</li> </ul> <p>Solutions: Bash<pre><code># Check file permissions\nls -la requirements.txt\n\n# Close editors that might lock the file\n# Try with elevated permissions if needed (Unix/macOS)\nsudo depkeeper update\n</code></pre></p>"},{"location":"guides/troubleshooting/#pre-release-versions-appearing","title":"Pre-release versions appearing","text":"<p>Issue: Unwanted alpha/beta versions suggested</p> <p>depkeeper automatically excludes pre-release versions (alpha, beta, rc, dev) by default. If you're seeing pre-releases, this may indicate:</p> <ul> <li>The package only has pre-release versions available</li> <li>The package's versioning scheme doesn't follow PEP 440</li> </ul> Bash<pre><code># Check available versions on PyPI directly\npip index versions package-name\n</code></pre>"},{"location":"guides/troubleshooting/#output-issues","title":"Output Issues","text":""},{"location":"guides/troubleshooting/#garbled-output-no-colors","title":"Garbled output / No colors","text":"<p>Issue: Terminal output appears broken</p> <p>Solutions: Bash<pre><code># Force no colors\ndepkeeper --no-color check\n\n# Or set environment variable\nexport DEPKEEPER_COLOR=false\n</code></pre></p>"},{"location":"guides/troubleshooting/#json-output-invalid","title":"JSON output invalid","text":"<p>Issue: JSON output mixed with status messages</p> <p>Solution: Bash<pre><code># Redirect stderr to get clean JSON output\ndepkeeper check --format json 2&gt;/dev/null\n</code></pre></p>"},{"location":"guides/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still having issues:</p> <ol> <li> <p>Check the version: Bash<pre><code>depkeeper --version\n</code></pre></p> </li> <li> <p>Run with verbose output: Bash<pre><code>depkeeper -vv check\n</code></pre></p> </li> <li> <p>Search existing issues:    GitHub Issues</p> </li> <li> <p>Report a bug -- include:</p> </li> <li>depkeeper version</li> <li>Python version (<code>python --version</code>)</li> <li>Operating system</li> <li>Full error message with verbose output</li> <li>Minimal requirements.txt to reproduce</li> </ol> Bash<pre><code># Gather system info\ndepkeeper --version\npython --version\npip --version\nuname -a  # or systeminfo on Windows\n</code></pre>"},{"location":"guides/troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Installation -- Installation troubleshooting</li> <li>Configuration -- Configure depkeeper behavior</li> <li>CLI Reference -- Complete command documentation</li> </ul>"},{"location":"guides/updating-dependencies/","title":"Updating Dependencies","text":"<p>The <code>update</code> command applies version updates to your requirements file with safety guardrails.</p>"},{"location":"guides/updating-dependencies/#basic-usage","title":"Basic Usage","text":"Bash<pre><code>depkeeper update\n</code></pre> <p>This:</p> <ol> <li>Analyzes your <code>requirements.txt</code></li> <li>Calculates safe version recommendations</li> <li>Shows a preview of proposed changes</li> <li>Asks for confirmation</li> <li>Updates the file</li> </ol>"},{"location":"guides/updating-dependencies/#preview-mode-dry-run","title":"Preview Mode (Dry Run)","text":"<p>See what would change without modifying any files:</p> Bash<pre><code>depkeeper update --dry-run\n</code></pre> Text Only<pre><code>Update Plan (Dry Run)\n\n  Package    Current   New Version   Change   Python Requires\n\n  requests    2.28.0      2.32.0      minor   &gt;=3.8\n  flask       2.0.0       2.3.3       patch   &gt;=3.7\n  click       8.0.0       8.1.7       minor   &gt;=3.7\n</code></pre> <p>Columns explained:</p> Column Description Package Normalized package name Current Version from your requirements file New Version The safe recommended version to update to Change Severity of the update (<code>patch</code>, <code>minor</code>, or <code>major</code>) Python Requires Required Python version for the new version <p>Best Practice</p> <p>Always run <code>--dry-run</code> first to review changes before applying them.</p>"},{"location":"guides/updating-dependencies/#skip-confirmation","title":"Skip Confirmation","text":"<p>For automated workflows, skip the interactive prompt:</p> Bash<pre><code>depkeeper update --yes\n# or\ndepkeeper update -y\n</code></pre>"},{"location":"guides/updating-dependencies/#create-backups","title":"Create Backups","text":"<p>Create a timestamped backup before making changes:</p> Bash<pre><code>depkeeper update --backup\n</code></pre> <p>This creates a backup file like:</p> Text Only<pre><code>requirements.txt.backup.20260208-143022\n</code></pre> <p>Combine with <code>-y</code> for automated workflows:</p> Bash<pre><code>depkeeper update --backup -y\n</code></pre>"},{"location":"guides/updating-dependencies/#update-specific-packages","title":"Update Specific Packages","text":"<p>Update only selected packages:</p> Bash<pre><code># Single package\ndepkeeper update -p requests\n\n# Multiple packages\ndepkeeper update -p requests -p flask -p click\n</code></pre> <p>Packages not specified are left unchanged.</p>"},{"location":"guides/updating-dependencies/#specifying-a-file","title":"Specifying a File","text":"<p>Update a specific requirements file:</p> Bash<pre><code>depkeeper update requirements-dev.txt\ndepkeeper update path/to/requirements.txt\n</code></pre>"},{"location":"guides/updating-dependencies/#understanding-update-types","title":"Understanding Update Types","text":"<p>depkeeper classifies updates by semantic versioning impact:</p> Type Description Example Risk Patch Bug fixes only <code>2.28.0</code> \u2192 <code>2.28.1</code> Low Minor New features, backward compatible <code>2.28.0</code> \u2192 <code>2.29.0</code> Medium Major Breaking changes <code>2.0.0</code> \u2192 <code>3.0.0</code> High"},{"location":"guides/updating-dependencies/#major-version-boundary","title":"Major Version Boundary","text":"<p>depkeeper never recommends crossing major version boundaries:</p> Text Only<pre><code>Package       Current    Latest     Recommended\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nflask         2.0.0      3.0.1      2.3.3        # Stays on 2.x\ndjango        3.2.0      5.0.2      3.2.24       # Stays on 3.x\n</code></pre> <p>This prevents unexpected breaking changes.</p>"},{"location":"guides/updating-dependencies/#conflict-resolution","title":"Conflict Resolution","text":"<p>When updating, depkeeper automatically resolves conflicts. Constrained packages show the dependency that restricts them in the check output, and the update plan reflects the safe resolved version:</p> Text Only<pre><code>Update Plan (Dry Run)\n\n  Package          Current   New Version   Change   Python Requires\n\n  pytest-asyncio    0.3.0      0.23.8       minor   &gt;=3.8\n  pytest            7.0.2      7.4.4        minor   &gt;=3.7\n</code></pre> <p>In this example, <code>pytest</code> is constrained by <code>pytest-asyncio</code> and depkeeper adjusts both recommendations to stay within compatible boundaries.</p>"},{"location":"guides/updating-dependencies/#disable-conflict-checking","title":"Disable Conflict Checking","text":"<p>For faster updates without resolution:</p> Bash<pre><code>depkeeper update --no-check-conflicts\n</code></pre> <p>Warning</p> <p>This may create dependency conflicts that break your environment.</p>"},{"location":"guides/updating-dependencies/#version-matching-options","title":"Version Matching Options","text":""},{"location":"guides/updating-dependencies/#strict-version-matching","title":"Strict Version Matching","text":"<p>Only update packages with exact version pins:</p> Bash<pre><code>depkeeper update --strict-version-matching\n</code></pre> <p>With this option:</p> <ul> <li><code>requests==2.28.0</code> -- Will be updated</li> <li><code>requests&gt;=2.0.0</code> -- Will be skipped (no exact version)</li> </ul>"},{"location":"guides/updating-dependencies/#complete-workflow-examples","title":"Complete Workflow Examples","text":""},{"location":"guides/updating-dependencies/#conservative-daily-update","title":"Conservative Daily Update","text":"Bash<pre><code># Check what's outdated\ndepkeeper check --outdated-only\n\n# Preview changes\ndepkeeper update --dry-run\n\n# Apply with backup\ndepkeeper update --backup -y\n\n# Run tests to verify\npytest\n</code></pre>"},{"location":"guides/updating-dependencies/#update-single-package","title":"Update Single Package","text":"Bash<pre><code># Preview the update\ndepkeeper update -p requests --dry-run\n\n# Apply it\ndepkeeper update -p requests -y\n</code></pre>"},{"location":"guides/updating-dependencies/#batch-update-with-review","title":"Batch Update with Review","text":"Bash<pre><code># Preview all changes\ndepkeeper update --dry-run\n\n# If everything looks good\ndepkeeper update --backup\n\n# Confirm interactively\nApply 5 updates? [y/N]: y\n</code></pre>"},{"location":"guides/updating-dependencies/#automated-ci-pipeline","title":"Automated CI Pipeline","text":"Bash<pre><code>#!/bin/bash\nset -e\n\n# Backup and update\ndepkeeper update --backup -y\n\n# Only proceed if tests pass\npytest\n\n# Commit changes if successful\ngit add requirements.txt\ngit commit -m \"chore: update dependencies\"\n</code></pre>"},{"location":"guides/updating-dependencies/#file-modifications","title":"File Modifications","text":""},{"location":"guides/updating-dependencies/#what-gets-updated","title":"What Gets Updated","text":"Text Only<pre><code># Before\nrequests==2.28.0\nflask==2.0.0\nclick&gt;=8.0.0\n\n# After\nrequests==2.32.0\nflask==2.3.3\nclick==8.1.7\n</code></pre> <p>depkeeper updates the version specifier to <code>==new_version</code>.</p>"},{"location":"guides/updating-dependencies/#preserved-elements","title":"Preserved Elements","text":"<ul> <li>Comments are preserved</li> <li>Line order is maintained</li> <li>Other specifiers (extras, markers) are kept</li> <li>Unupdated packages remain unchanged</li> </ul>"},{"location":"guides/updating-dependencies/#verbosity","title":"Verbosity","text":"<p>Get more detail about the update process:</p> Bash<pre><code># Info level\ndepkeeper -v update\n\n# Debug level (shows HTTP requests, timing)\ndepkeeper -vv update\n</code></pre>"},{"location":"guides/updating-dependencies/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> Success <code>1</code> Error (parse failure, write error) <code>2</code> Usage error (invalid arguments) <code>130</code> Cancelled by user"},{"location":"guides/updating-dependencies/#next-steps","title":"Next Steps","text":"<ul> <li>Dependency Resolution -- Understand conflict handling</li> <li>CI/CD Integration -- Automate updates</li> <li>CLI Reference -- Complete command documentation</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>Complete technical reference documentation for depkeeper. These pages provide detailed specifications for the CLI, Python API, configuration, file formats, and exit codes.</p>"},{"location":"reference/#reference-sections","title":"Reference Sections","text":"<ul> <li> <p> CLI Commands</p> <p>Complete command-line interface reference with all options and examples.</p> <p> View commands</p> </li> <li> <p> Python API</p> <p>Programmatic interface for integrating depkeeper into your tools.</p> <p> View API</p> </li> <li> <p> Configuration Options</p> <p>All configuration options, environment variables, and defaults.</p> <p> View options</p> </li> <li> <p> Exit Codes</p> <p>Exit code meanings for scripting and CI/CD integration.</p> <p> View codes</p> </li> <li> <p> File Formats</p> <p>Supported file format specifications and syntax reference.</p> <p> View formats</p> </li> </ul>"},{"location":"reference/#quick-reference","title":"Quick Reference","text":""},{"location":"reference/#most-common-commands","title":"Most Common Commands","text":"Bash<pre><code># Check for updates\ndepkeeper check\n\n# Update all packages\ndepkeeper update\n\n# Preview updates without applying\ndepkeeper update --dry-run\n\n# Update with backup\ndepkeeper update --backup -y\n\n# JSON output for CI\ndepkeeper check --format json\n</code></pre>"},{"location":"reference/#environment-variables","title":"Environment Variables","text":"Variable Description <code>DEPKEEPER_CONFIG</code> Configuration file path <code>DEPKEEPER_COLOR</code> Enable/disable colors"},{"location":"reference/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> Success <code>1</code> Error <code>2</code> Usage error <code>130</code> Interrupted"},{"location":"reference/#version-information","title":"Version Information","text":"<p>Current version: 0.1.0</p> Bash<pre><code>depkeeper --version\n</code></pre> <p>See the Changelog for version history.</p>"},{"location":"reference/cli-commands/","title":"CLI Commands","text":"<p>Complete reference for all depkeeper command-line options. depkeeper provides two main commands -- <code>check</code> and <code>update</code> -- along with global options that apply to both.</p>"},{"location":"reference/cli-commands/#command-overview","title":"Command Overview","text":"Command Steps <code>depkeeper check</code> Parse file \u2192 Query PyPI \u2192 Resolve conflicts \u2192 Display report <code>depkeeper update</code> Parse file \u2192 Query PyPI \u2192 Resolve conflicts \u2192 Apply updates <p>Both commands share global options described below.</p>"},{"location":"reference/cli-commands/#global-options","title":"Global Options","text":"<p>These options are available for all commands:</p> Bash<pre><code>depkeeper [OPTIONS] COMMAND [ARGS]...\n</code></pre> Option Short Description <code>--config PATH</code> <code>-c</code> Path to configuration file <code>--verbose</code> <code>-v</code> Increase verbosity (repeat for more: <code>-v</code>, <code>-vv</code>) <code>--color / --no-color</code> Enable/disable colored output <code>--version</code> Show version and exit <code>--help</code> <code>-h</code> Show help message"},{"location":"reference/cli-commands/#verbosity-levels","title":"Verbosity Levels","text":"Level Flag Logging Default (none) WARNING Verbose <code>-v</code> INFO Debug <code>-vv</code> DEBUG"},{"location":"reference/cli-commands/#examples","title":"Examples","text":"Bash<pre><code># Use specific config file\ndepkeeper -c /path/to/config.toml check\n\n# Verbose output\ndepkeeper -v check\ndepkeeper -vv check  # Debug level\n\n# Disable colors\ndepkeeper --no-color check\n\n# Show version\ndepkeeper --version\n</code></pre>"},{"location":"reference/cli-commands/#check","title":"check","text":"<p>Check for available updates in a requirements file.</p>"},{"location":"reference/cli-commands/#synopsis","title":"Synopsis","text":"Bash<pre><code>depkeeper check [OPTIONS] [FILE]\n</code></pre>"},{"location":"reference/cli-commands/#arguments","title":"Arguments","text":"Argument Description Default <code>FILE</code> Path to requirements file <code>requirements.txt</code>"},{"location":"reference/cli-commands/#options","title":"Options","text":"Option Short Description Default <code>--outdated-only</code> Show only packages with available updates <code>False</code> <code>--format</code> <code>-f</code> Output format: <code>table</code>, <code>simple</code>, <code>json</code> <code>table</code> <code>--strict-version-matching</code> Only consider exact version pins (<code>==</code>) <code>False</code> <code>--check-conflicts / --no-check-conflicts</code> Enable/disable dependency conflict resolution <code>True</code> <p>Configuration File Fallback</p> <p><code>--strict-version-matching</code> and <code>--check-conflicts</code> fall back to values from your <code>depkeeper.toml</code> or <code>pyproject.toml</code> when not provided on the command line. See Configuration for details.</p>"},{"location":"reference/cli-commands/#how-it-works","title":"How It Works","text":"<ol> <li>Parse -- Read and parse the requirements file (PEP 440/508 compliant)</li> <li>Query PyPI -- Fetch latest version metadata concurrently via async HTTP</li> <li>Recommend -- Compute safe upgrade targets within major version boundaries</li> <li>Resolve -- Cross-validate recommendations and resolve dependency conflicts</li> <li>Report -- Display results in the requested format</li> </ol>"},{"location":"reference/cli-commands/#output-formats","title":"Output Formats","text":""},{"location":"reference/cli-commands/#table-default","title":"Table (default)","text":"<p>Human-readable table with colors:</p> Bash<pre><code>depkeeper check --format table\n</code></pre> Text Only<pre><code>Package       Current    Latest     Recommended  Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nrequests      2.28.0     2.32.0     2.32.0       Outdated (minor)\nflask         2.0.0      3.0.1      2.3.3        Outdated (patch)\n</code></pre>"},{"location":"reference/cli-commands/#simple","title":"Simple","text":"<p>One line per package:</p> Bash<pre><code>depkeeper check --format simple\n</code></pre> Text Only<pre><code>requests: 2.28.0 -&gt; 2.32.0 (minor)\nflask: 2.0.0 -&gt; 2.3.3 (patch)\n</code></pre>"},{"location":"reference/cli-commands/#json","title":"JSON","text":"<p>Machine-readable JSON:</p> Bash<pre><code>depkeeper check --format json\n</code></pre> JSON<pre><code>[\n  {\n    \"name\": \"requests\",\n    \"status\": \"outdated\",\n    \"versions\": {\n      \"current\": \"2.28.0\",\n      \"latest\": \"2.32.0\",\n      \"recommended\": \"2.32.0\"\n    },\n    \"update_type\": \"minor\"\n  }\n]\n</code></pre>"},{"location":"reference/cli-commands/#examples_1","title":"Examples","text":"Bash<pre><code># Basic check\ndepkeeper check\n\n# Check specific file\ndepkeeper check requirements-dev.txt\n\n# Show only outdated\ndepkeeper check --outdated-only\n\n# JSON output for CI\ndepkeeper check --format json &gt; report.json\n\n# Disable conflict checking (faster)\ndepkeeper check --no-check-conflicts\n\n# Strict mode: only exact pins\ndepkeeper check --strict-version-matching\n</code></pre>"},{"location":"reference/cli-commands/#update","title":"update","text":"<p>Update packages to newer versions within safe major version boundaries.</p>"},{"location":"reference/cli-commands/#synopsis_1","title":"Synopsis","text":"Bash<pre><code>depkeeper update [OPTIONS] [FILE]\n</code></pre>"},{"location":"reference/cli-commands/#arguments_1","title":"Arguments","text":"Argument Description Default <code>FILE</code> Path to requirements file <code>requirements.txt</code>"},{"location":"reference/cli-commands/#options_1","title":"Options","text":"Option Short Description Default <code>--dry-run</code> Preview changes without applying <code>False</code> <code>--yes</code> <code>-y</code> Skip confirmation prompt <code>False</code> <code>--backup</code> Create backup before updating <code>False</code> <code>--packages</code> <code>-p</code> Update only specific packages (repeatable) All <code>--strict-version-matching</code> Only consider exact version pins <code>False</code> <code>--check-conflicts / --no-check-conflicts</code> Enable/disable conflict resolution <code>True</code> <p>Configuration File Fallback</p> <p><code>--strict-version-matching</code> and <code>--check-conflicts</code> fall back to values from your <code>depkeeper.toml</code> or <code>pyproject.toml</code> when not provided on the command line. See Configuration for details.</p>"},{"location":"reference/cli-commands/#update-process","title":"Update Process","text":"<ol> <li>Parse -- Read the requirements file</li> <li>Check -- Query PyPI for available versions</li> <li>Resolve -- Check for dependency conflicts (if enabled)</li> <li>Preview -- Show proposed changes</li> <li>Confirm -- Ask for user confirmation (unless <code>-y</code>)</li> <li>Backup -- Create backup (if <code>--backup</code>)</li> <li>Apply -- Update the requirements file</li> <li>Report -- Show summary of changes</li> </ol>"},{"location":"reference/cli-commands/#backup-files","title":"Backup Files","text":"<p>When <code>--backup</code> is used, a timestamped backup is created:</p> Text Only<pre><code>requirements.txt.backup.20260208-143022\n</code></pre> <p>Format: <code>{filename}.backup.{YYYYMMDD}-{HHMMSS}</code></p>"},{"location":"reference/cli-commands/#examples_2","title":"Examples","text":"Bash<pre><code># Basic update (with confirmation)\ndepkeeper update\n\n# Preview changes\ndepkeeper update --dry-run\n\n# Update without confirmation\ndepkeeper update -y\n\n# Create backup before updating\ndepkeeper update --backup\n\n# Update specific packages only\ndepkeeper update -p requests -p flask\n\n# Combine options\ndepkeeper update --backup -y -p requests\n\n# Update specific file\ndepkeeper update requirements-dev.txt --backup -y\n\n# Disable conflict checking\ndepkeeper update --no-check-conflicts -y\n</code></pre>"},{"location":"reference/cli-commands/#command-chaining","title":"Command Chaining","text":"<p>depkeeper commands can be chained in scripts:</p> Bash<pre><code>#!/bin/bash\nset -e\n\n# Check first\nif depkeeper check --outdated-only --format simple | grep -q .; then\n    echo \"Updates available\"\n\n    # Preview\n    depkeeper update --dry-run\n\n    # Apply with backup\n    depkeeper update --backup -y\n\n    # Verify\n    pip install -r requirements.txt\n    pytest\nfi\n</code></pre>"},{"location":"reference/cli-commands/#environment-variables","title":"Environment Variables","text":"<p>Commands respect these environment variables:</p> Variable Affects <code>DEPKEEPER_CONFIG</code> <code>--config</code> option <code>DEPKEEPER_COLOR</code> <code>--color</code> option <code>NO_COLOR</code> Disables colors (standard)"},{"location":"reference/cli-commands/#exit-codes","title":"Exit Codes","text":"Code Meaning <code>0</code> Success <code>1</code> Application error <code>2</code> Usage/argument error <code>130</code> Interrupted (Ctrl+C) <p>See Exit Codes for detailed descriptions and scripting examples.</p>"},{"location":"reference/cli-commands/#see-also","title":"See Also","text":"<ul> <li>Quick Start -- Getting started guide</li> <li>Configuration -- Configuration options</li> <li>CI/CD Integration -- Pipeline integration</li> <li>Exit Codes -- Exit code reference</li> </ul>"},{"location":"reference/configuration-options/","title":"Configuration Options","text":"<p>Complete reference for all depkeeper configuration options. depkeeper supports CLI arguments, environment variables, and configuration files with a clear precedence hierarchy. Configuration file values serve as defaults that CLI arguments override.</p>"},{"location":"reference/configuration-options/#configuration-precedence","title":"Configuration Precedence","text":"<p>When the same option is set in multiple places, the highest-priority source wins:</p> <ol> <li>CLI arguments -- Highest priority</li> <li>Environment variables -- <code>DEPKEEPER_*</code></li> <li>Configuration files -- <code>depkeeper.toml</code> or <code>pyproject.toml</code></li> <li>Built-in defaults -- Lowest priority</li> </ol>"},{"location":"reference/configuration-options/#cli-options","title":"CLI Options","text":""},{"location":"reference/configuration-options/#global-options","title":"Global Options","text":"Option Type Default Description <code>--config</code>, <code>-c</code> Path Auto-detect Configuration file path <code>--verbose</code>, <code>-v</code> Flag 0 Verbosity level (repeat for more) <code>--color</code> Boolean <code>true</code> Enable colored output <code>--no-color</code> Boolean <code>false</code> Disable colored output"},{"location":"reference/configuration-options/#check-command-options","title":"check Command Options","text":"Option Type Default Description <code>--outdated-only</code> Flag <code>false</code> Show only outdated packages <code>--format</code>, <code>-f</code> Choice <code>table</code> Output format: <code>table</code>, <code>simple</code>, <code>json</code> <code>--strict-version-matching</code> Flag <code>false</code> Only consider exact pins (<code>==</code>) <code>--check-conflicts</code> Flag <code>true</code> Enable conflict resolution <code>--no-check-conflicts</code> Flag <code>false</code> Disable conflict resolution"},{"location":"reference/configuration-options/#update-command-options","title":"update Command Options","text":"Option Type Default Description <code>--dry-run</code> Flag <code>false</code> Preview without applying <code>--yes</code>, <code>-y</code> Flag <code>false</code> Skip confirmation <code>--backup</code> Flag <code>false</code> Create backup file <code>--packages</code>, <code>-p</code> String All Packages to update (repeatable) <code>--strict-version-matching</code> Flag <code>false</code> Only consider exact pins <code>--check-conflicts</code> Flag <code>true</code> Enable conflict resolution <p>For full details on each command, see CLI Commands.</p>"},{"location":"reference/configuration-options/#environment-variables","title":"Environment Variables","text":"<p>All environment variables use the <code>DEPKEEPER_</code> prefix:</p> Variable Type Default Description <code>DEPKEEPER_CONFIG</code> Path - Configuration file path <code>DEPKEEPER_COLOR</code> Boolean <code>true</code> Enable/disable colors"},{"location":"reference/configuration-options/#boolean-values","title":"Boolean Values","text":"<p>Boolean environment variables accept:</p> <ul> <li>True: <code>true</code>, <code>1</code>, <code>yes</code>, <code>on</code></li> <li>False: <code>false</code>, <code>0</code>, <code>no</code>, <code>off</code></li> </ul>"},{"location":"reference/configuration-options/#standard-variables","title":"Standard Variables","text":"<p>depkeeper also respects the <code>NO_COLOR</code> environment variable as defined by the no-color standard. When set, colored output is disabled regardless of <code>DEPKEEPER_COLOR</code>.</p>"},{"location":"reference/configuration-options/#examples","title":"Examples","text":"Bash<pre><code># Disable colors\nexport DEPKEEPER_COLOR=false\n</code></pre>"},{"location":"reference/configuration-options/#configuration-files","title":"Configuration Files","text":""},{"location":"reference/configuration-options/#file-locations","title":"File Locations","text":"<p>depkeeper searches for configuration in this order:</p> <ol> <li>Path from <code>--config</code> or <code>DEPKEEPER_CONFIG</code></li> <li><code>depkeeper.toml</code> in the current directory</li> <li><code>pyproject.toml</code> under <code>[tool.depkeeper]</code></li> </ol>"},{"location":"reference/configuration-options/#depkeepertoml","title":"depkeeper.toml","text":"TOML<pre><code># depkeeper.toml\n\n[depkeeper]\ncheck_conflicts = true\nstrict_version_matching = false\n</code></pre>"},{"location":"reference/configuration-options/#pyprojecttoml","title":"pyproject.toml","text":"TOML<pre><code># pyproject.toml\n\n[tool.depkeeper]\ncheck_conflicts = true\nstrict_version_matching = false\n</code></pre>"},{"location":"reference/configuration-options/#configuration-file-reference","title":"Configuration File Reference","text":"<p>These options can be set in the <code>[depkeeper]</code> table of <code>depkeeper.toml</code> or the <code>[tool.depkeeper]</code> table of <code>pyproject.toml</code>.</p> Option Type Default Description <code>check_conflicts</code> Boolean <code>true</code> Enable dependency conflict resolution <code>strict_version_matching</code> Boolean <code>false</code> Only use exact version pins (<code>==</code>)"},{"location":"reference/configuration-options/#precedence-example","title":"Precedence Example","text":"<p>Given the following configuration:</p> <p>depkeeper.toml:</p> TOML<pre><code>[depkeeper]\ncheck_conflicts = true\n</code></pre> <p>Environment:</p> Bash<pre><code>export DEPKEEPER_COLOR=false\n</code></pre> <p>Command:</p> Bash<pre><code>depkeeper check --no-check-conflicts\n</code></pre> <p>Effective configuration:</p> Option Value Source <code>check_conflicts</code> <code>false</code> CLI wins <code>color</code> <code>false</code> From environment"},{"location":"reference/configuration-options/#example-configurations","title":"Example Configurations","text":""},{"location":"reference/configuration-options/#development-environment","title":"Development Environment","text":"TOML<pre><code># depkeeper.toml\n\n[depkeeper]\ncheck_conflicts = true\n</code></pre>"},{"location":"reference/configuration-options/#production-conservative","title":"Production / Conservative","text":"TOML<pre><code># depkeeper.toml\n\n[depkeeper]\ncheck_conflicts = true\nstrict_version_matching = true\n</code></pre>"},{"location":"reference/configuration-options/#validation","title":"Validation","text":"<p>depkeeper validates configuration on startup. Invalid values result in clear error messages:</p> Bash<pre><code>$ depkeeper check\nError: Invalid configuration: check_conflicts must be a boolean, got str\n</code></pre> <p>Use verbose mode to debug configuration loading:</p> Bash<pre><code>depkeeper -vv check 2&gt;&amp;1 | grep config\n</code></pre>"},{"location":"reference/configuration-options/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide -- Practical configuration guide</li> <li>CLI Commands -- Command options reference</li> <li>CI/CD Integration -- Pipeline configuration</li> </ul>"},{"location":"reference/exit-codes/","title":"Exit Codes","text":"<p>depkeeper uses meaningful exit codes for scripting and CI/CD integration. This page documents each exit code, its meaning, and how to handle it in automation scripts.</p>"},{"location":"reference/exit-codes/#exit-code-reference","title":"Exit Code Reference","text":"Code Name Description <code>0</code> Success Command completed successfully <code>1</code> Error Application or runtime error <code>2</code> Usage Error Invalid arguments or options <code>130</code> Interrupted User cancelled (Ctrl+C)"},{"location":"reference/exit-codes/#detailed-descriptions","title":"Detailed Descriptions","text":""},{"location":"reference/exit-codes/#exit-code-0-success","title":"Exit Code 0: Success","text":"<p>The command completed without errors.</p> <ul> <li>check -- Requirements file was parsed and analyzed</li> <li>update -- Updates were applied successfully, or no updates were needed</li> </ul> <p>Note</p> <p>The <code>check</code> command returns 0 even if outdated packages are found. The exit code indicates command success, not whether updates are available.</p>"},{"location":"reference/exit-codes/#exit-code-1-error","title":"Exit Code 1: Error","text":"<p>An application error occurred. Common causes:</p> <ul> <li>Requirements file not found</li> <li>Parse error in requirements file</li> <li>Network error (PyPI unreachable)</li> <li>File write error (during update)</li> <li>Invalid configuration</li> </ul>"},{"location":"reference/exit-codes/#exit-code-2-usage-error","title":"Exit Code 2: Usage Error","text":"<p>Invalid command-line arguments were provided. Common causes:</p> <ul> <li>Unknown option</li> <li>Missing required argument</li> <li>Invalid option value</li> </ul>"},{"location":"reference/exit-codes/#exit-code-130-interrupted","title":"Exit Code 130: Interrupted","text":"<p>The user cancelled the operation with Ctrl+C. This occurs when:</p> <ul> <li>The user presses Ctrl+C during an update confirmation prompt</li> <li>The user interrupts a long-running network operation</li> </ul>"},{"location":"reference/exit-codes/#exit-code-behavior-by-command","title":"Exit Code Behavior by Command","text":""},{"location":"reference/exit-codes/#check","title":"check","text":"Scenario Exit Code All packages up to date 0 Outdated packages found 0 Parse error 1 Network error 1 Invalid arguments 2 Interrupted 130"},{"location":"reference/exit-codes/#update","title":"update","text":"Scenario Exit Code Updates applied successfully 0 No updates needed 0 User declined updates 0 Parse error 1 Write error 1 Network error 1 Invalid arguments 2 Interrupted 130"},{"location":"reference/exit-codes/#usage-in-scripts","title":"Usage in Scripts","text":""},{"location":"reference/exit-codes/#basic-error-handling-bash","title":"Basic Error Handling (Bash)","text":"Bash<pre><code>#!/bin/bash\nset -e\n\ndepkeeper check || {\n    echo \"depkeeper check failed\"\n    exit 1\n}\n</code></pre>"},{"location":"reference/exit-codes/#detailed-exit-code-handling-bash","title":"Detailed Exit Code Handling (Bash)","text":"Bash<pre><code>#!/bin/bash\n\ndepkeeper check\nEXIT_CODE=$?\n\ncase $EXIT_CODE in\n    0)\n        echo \"Check completed successfully\"\n        ;;\n    1)\n        echo \"Error during check\"\n        exit 1\n        ;;\n    2)\n        echo \"Invalid arguments\"\n        exit 2\n        ;;\n    130)\n        echo \"Operation cancelled\"\n        exit 130\n        ;;\n    *)\n        echo \"Unknown exit code: $EXIT_CODE\"\n        exit $EXIT_CODE\n        ;;\nesac\n</code></pre>"},{"location":"reference/exit-codes/#powershell","title":"PowerShell","text":"PowerShell<pre><code>depkeeper check\nif ($LASTEXITCODE -eq 0) {\n    Write-Host \"Check completed successfully\"\n} else {\n    Write-Host \"Check failed with code: $LASTEXITCODE\"\n    exit $LASTEXITCODE\n}\n</code></pre>"},{"location":"reference/exit-codes/#cicd-pipeline","title":"CI/CD Pipeline","text":"Bash<pre><code>#!/bin/bash\nset -e\n\n# Check for updates (exit 0 even with outdated)\ndepkeeper check --format json &gt; report.json\n\n# Determine if updates exist\nOUTDATED=$(jq '[.[] | select(.status == \"outdated\")] | length' report.json)\n\nif [ \"$OUTDATED\" -gt 0 ]; then\n    echo \"Found $OUTDATED outdated packages\"\n\n    # Update with backup\n    depkeeper update --backup -y || {\n        echo \"Update failed\"\n        exit 1\n    }\n\n    # Run tests\n    pytest || {\n        echo \"Tests failed after update\"\n        exit 1\n    }\nfi\n</code></pre>"},{"location":"reference/exit-codes/#github-actions","title":"GitHub Actions","text":"YAML<pre><code>- name: Check dependencies\n  id: check\n  run: |\n    depkeeper check --format json &gt; report.json\n  continue-on-error: true\n\n- name: Handle check result\n  if: steps.check.outcome == 'failure'\n  run: |\n    echo \"::error::Dependency check failed\"\n    exit 1\n</code></pre>"},{"location":"reference/exit-codes/#strict-mode-pattern","title":"Strict Mode Pattern","text":"<p>For CI/CD where you want to fail if packages are outdated:</p> Bash<pre><code>#!/bin/bash\nset -e\n\n# Check if any packages are outdated\nOUTDATED=$(depkeeper check --outdated-only --format json | jq 'length')\n\nif [ \"$OUTDATED\" -gt 0 ]; then\n    echo \"$OUTDATED packages are outdated\"\n    depkeeper check --outdated-only\n    exit 1\nfi\n\necho \"All packages are up to date\"\n</code></pre>"},{"location":"reference/exit-codes/#see-also","title":"See Also","text":"<ul> <li>CLI Commands -- Command documentation</li> <li>CI/CD Integration -- Pipeline examples</li> </ul>"},{"location":"reference/file-formats/","title":"File Formats","text":"<p>Reference for all file formats supported by depkeeper. This page covers the requirements file syntax, configuration file formats, and backup file conventions.</p>"},{"location":"reference/file-formats/#requirementstxt","title":"requirements.txt","text":"<p>The standard pip requirements format (PEP 508). This is the primary file format depkeeper reads and updates.</p>"},{"location":"reference/file-formats/#version-specifiers","title":"Version Specifiers","text":"Operator Meaning Example <code>==</code> Exact version <code>requests==2.31.0</code> <code>&gt;=</code> Minimum version <code>requests&gt;=2.28.0</code> <code>&lt;=</code> Maximum version <code>requests&lt;=3.0.0</code> <code>&gt;</code> Greater than <code>requests&gt;2.27.0</code> <code>&lt;</code> Less than <code>requests&lt;3.0.0</code> <code>!=</code> Not equal <code>requests!=2.29.0</code> <code>~=</code> Compatible release <code>requests~=2.31.0</code>"},{"location":"reference/file-formats/#compatible-release","title":"Compatible Release (<code>~=</code>)","text":"<p>The <code>~=</code> operator allows patch updates but not minor/major:</p> INI<pre><code># Equivalent to &gt;=2.31.0, ==2.31.*\nrequests~=2.31.0\n\n# Equivalent to &gt;=2.31, ==2.*\nrequests~=2.31\n</code></pre>"},{"location":"reference/file-formats/#basic-syntax","title":"Basic Syntax","text":"INI<pre><code># Package with exact version\nrequests==2.31.0\n\n# Package with version constraints\nflask&gt;=2.0.0,&lt;3.0.0\n\n# Package without version (latest)\nclick\n\n# Combined constraints\nrequests&gt;=2.28.0,&lt;3.0.0,!=2.29.0\n</code></pre>"},{"location":"reference/file-formats/#extras","title":"Extras","text":"<p>Install optional dependencies:</p> INI<pre><code># Single extra\nrequests[security]==2.31.0\n\n# Multiple extras\npackage[extra1,extra2]==1.0.0\n</code></pre>"},{"location":"reference/file-formats/#environment-markers","title":"Environment Markers","text":"<p>Conditional installations based on environment:</p> INI<pre><code># Python version\ndataclasses==0.6; python_version &lt; \"3.7\"\n\n# Platform\npywin32==305; sys_platform == \"win32\"\n\n# Implementation\nuvloop&gt;=0.18.0; implementation_name == \"cpython\"\n\n# Combined\npackage==1.0.0; python_version &gt;= \"3.8\" and sys_platform != \"win32\"\n</code></pre>"},{"location":"reference/file-formats/#url-and-vcs-requirements","title":"URL and VCS Requirements","text":"INI<pre><code># Git repository\ngit+https://github.com/user/project.git\n\n# Specific branch\ngit+https://github.com/user/project.git@main\n\n# Specific tag\ngit+https://github.com/user/project.git@v1.0.0\n\n# Specific commit\ngit+https://github.com/user/project.git@abc123\n\n# With package name\nproject @ git+https://github.com/user/project.git@v1.0.0\n</code></pre> <p>depkeeper supports <code>git+</code>, <code>bzr+</code>, <code>hg+</code>, <code>svn+</code>, <code>https://</code>, <code>http://</code>, and <code>file://</code> URL schemes.</p>"},{"location":"reference/file-formats/#editable-installs","title":"Editable Installs","text":"INI<pre><code># Local package in development\n-e .\n\n# Local package at path\n-e /path/to/package\n\n# Local package with extras\n-e .[dev,test]\n</code></pre>"},{"location":"reference/file-formats/#include-and-constraint-directives","title":"Include and Constraint Directives","text":"INI<pre><code># Include another requirements file\n-r requirements-base.txt\n--requirement requirements-base.txt\n\n# Constraints file (version limits, not installs)\n-c constraints.txt\n--constraint constraints.txt\n</code></pre> <p>depkeeper follows include chains and detects circular dependencies. Constraints loaded via <code>-c</code> are applied to matching package names during parsing.</p>"},{"location":"reference/file-formats/#hash-verification","title":"Hash Verification","text":"INI<pre><code>requests==2.31.0 \\\n    --hash=sha256:942c5a758f98d790eaed1a29cb6eefc7ffb0d1cf7af05c3d2791656dbd6ad1e1\n</code></pre>"},{"location":"reference/file-formats/#comments-and-blank-lines","title":"Comments and Blank Lines","text":"INI<pre><code># This is a comment\nrequests==2.31.0  # Inline comment\n\n# Blank lines are ignored\n\nflask==3.0.0\n</code></pre>"},{"location":"reference/file-formats/#depkeepertoml","title":"depkeeper.toml","text":"<p>Project configuration file for depkeeper settings.</p> TOML<pre><code>[depkeeper]\ncheck_conflicts = true\nstrict_version_matching = false\n</code></pre> <p>For the full list of options and their descriptions, see Configuration Options.</p>"},{"location":"reference/file-formats/#pyprojecttoml-integration","title":"pyproject.toml Integration","text":"<p>depkeeper reads configuration from <code>pyproject.toml</code> under the <code>[tool.depkeeper]</code> section:</p> TOML<pre><code>[project]\nname = \"my-project\"\nversion = \"1.0.0\"\ndependencies = [\n    \"requests&gt;=2.28.0\",\n    \"flask&gt;=2.0.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest&gt;=7.0.0\",\n    \"black&gt;=23.0.0\",\n]\n\n[tool.depkeeper]\ncheck_conflicts = true\nstrict_version_matching = false\n</code></pre>"},{"location":"reference/file-formats/#backup-files","title":"Backup Files","text":"<p>When <code>--backup</code> is used with the <code>update</code> command, depkeeper creates a timestamped backup:</p> Text Only<pre><code>requirements.txt.backup.20260208-143022\n</code></pre> <p>Format: <code>{filename}.backup.{YYYYMMDD}-{HHMMSS}</code></p> <p>Backup files are plain copies of the original requirements file. They can be restored by renaming or copying them back to the original filename.</p>"},{"location":"reference/file-formats/#see-also","title":"See Also","text":"<ul> <li>CLI Commands -- Working with files via CLI</li> <li>Configuration Options -- Full configuration reference</li> <li>Python API -- Programmatic file handling</li> </ul>"},{"location":"reference/python-api/","title":"Python API","text":"<p>Use depkeeper programmatically in your Python scripts and tools. This page documents the core modules, data models, and utility functions available for integration.</p>"},{"location":"reference/python-api/#overview","title":"Overview","text":"<p>Core pipeline:</p> Step Module Input Output 1 <code>RequirementsParser</code> requirements file <code>List[Requirement]</code> 2 <code>VersionChecker</code> <code>List[Requirement]</code> <code>List[Package]</code> 3 <code>DependencyAnalyzer</code> <code>List[Package]</code> <code>ResolutionResult</code> 4 Apply / Report <code>ResolutionResult</code> Updated file or report <p><code>PyPIDataStore</code> backs both <code>VersionChecker</code> and <code>DependencyAnalyzer</code>, and is itself backed by <code>HTTPClient</code>.</p> <p>depkeeper provides a Python API for:</p> <ul> <li>Parsing <code>requirements.txt</code> files into structured <code>Requirement</code> objects</li> <li>Checking package versions against PyPI with strict major version boundaries</li> <li>Resolving dependency conflicts through iterative analysis</li> <li>Formatting and displaying results</li> </ul> <p>All core modules share a single <code>PyPIDataStore</code> instance to ensure each package is fetched at most once per process.</p>"},{"location":"reference/python-api/#quick-start","title":"Quick Start","text":"Python<pre><code>import asyncio\nfrom depkeeper.core import RequirementsParser, VersionChecker, PyPIDataStore\nfrom depkeeper.utils import HTTPClient\n\nasync def check_requirements():\n    # Parse requirements file\n    parser = RequirementsParser()\n    requirements = parser.parse_file(\"requirements.txt\")\n\n    # Check versions\n    async with HTTPClient() as http:\n        store = PyPIDataStore(http)\n        checker = VersionChecker(data_store=store)\n        packages = await checker.check_packages(requirements)\n\n    # Report\n    for pkg in packages:\n        if pkg.has_update():\n            print(f\"{pkg.name}: {pkg.current_version} -&gt; {pkg.recommended_version}\")\n\nasyncio.run(check_requirements())\n</code></pre>"},{"location":"reference/python-api/#core-modules","title":"Core Modules","text":""},{"location":"reference/python-api/#requirementsparser","title":"RequirementsParser","text":"<p>Stateful parser for pip-style requirements files. Supports all PEP 440/508 syntax including version specifiers, extras, environment markers, include directives (<code>-r</code>), constraint files (<code>-c</code>), VCS URLs, editable installs, and hash verification.</p> <p>The parser maintains internal state across multiple <code>parse_file</code> calls:</p> <ul> <li>Include stack -- tracks the chain of <code>-r</code> directives to detect circular dependencies</li> <li>Constraint map -- stores requirements loaded via <code>-c</code> directives</li> </ul> <p>Call <code>reset()</code> to clear state before reusing the parser on an unrelated set of files.</p> Python<pre><code>from depkeeper.core import RequirementsParser\n\nparser = RequirementsParser()\n\n# Parse from file\nrequirements = parser.parse_file(\"requirements.txt\")\n\n# Parse from string\ncontent = \"\"\"\nrequests&gt;=2.28.0\nflask==2.3.0\n-r base.txt\n\"\"\"\nrequirements = parser.parse_string(content, source_file_path=\"inline\")\n\n# Access constraint files loaded via -c\nconstraints = parser.get_constraints()\n\n# Reset state before reusing\nparser.reset()\n</code></pre>"},{"location":"reference/python-api/#methods","title":"Methods","text":"<p>Stateful parser for pip-style requirements files.</p> <p>Maintains two pieces of internal state across multiple <code>parse_file</code> calls:</p> <ol> <li>Include stack \u2014 tracks the chain of <code>-r</code> directives to detect    circular dependencies.</li> <li>Constraint map \u2014 stores all requirements loaded via <code>-c</code>    directives; these are applied to matching package names during    parsing.</li> </ol> <p>Call :meth:<code>reset</code> to clear state before reusing the parser on an unrelated set of files.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; parser = RequirementsParser()\n&gt;&gt;&gt; reqs = parser.parse_file(\"requirements.txt\")\n&gt;&gt;&gt; len(reqs)\n42\n&gt;&gt;&gt; parser.get_constraints()\n{'django': &lt;Requirement django==3.2&gt;}\n&gt;&gt;&gt; parser.reset()\n</code></pre> <p>Initialise the parser with empty state.</p> Source code in <code>depkeeper/core/parser.py</code> Python<pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialise the parser with empty state.\"\"\"\n    self.logger = get_logger(\"parser\")\n\n    # Stack of files currently being parsed (guards against cycles)\n    self._included_files_stack: List[Path] = []\n\n    # Constraint requirements loaded via -c directives\n    self._constraint_requirements: Dict[str, Requirement] = {}\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.RequirementsParser-functions","title":"Functions","text":""},{"location":"reference/python-api/#depkeeper.core.RequirementsParser.parse_file","title":"parse_file","text":"Python<pre><code>parse_file(file_path: Union[str, Path], is_constraint_file: bool = False, _parent_directory_path: Optional[Path] = None) -&gt; List[Requirement]\n</code></pre> <p>Parse a requirements file from disk.</p> <p>Reads the file at file_path, processes all directives (<code>-r</code>, <code>-c</code>, <code>-e</code>, <code>--hash</code>), and returns a flat list of :class:<code>Requirement</code> objects.  If file_path is relative and _parent_directory_path is provided (internal use by <code>-r</code>), the path is resolved relative to the parent.</p> <p>Circular include chains (<code>A.txt</code> includes <code>B.txt</code> which includes <code>A.txt</code>) are detected and raise :exc:<code>ParseError</code>.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the requirements file (absolute or relative).</p> <p> TYPE: <code>Union[str, Path]</code> </p> <code>is_constraint_file</code> <p>If <code>True</code>, all parsed requirements are stored as constraints (via :attr:<code>_constraint_requirements</code>) rather than returned.  Used internally by <code>-c</code> handlers.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>_parent_directory_path</code> <p>Internal parameter used when resolving <code>-r</code> includes; the parent's directory is used as the base for relative paths.</p> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Requirement]</code> <p>List of :class:<code>Requirement</code> objects (empty if</p> <code>List[Requirement]</code> <p>is_constraint_file is <code>True</code>).</p> RAISES DESCRIPTION <code>FileOperationError</code> <p>The file does not exist or cannot be read.</p> <code>ParseError</code> <p>A circular include was detected or the file contains invalid syntax.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; parser = RequirementsParser()\n&gt;&gt;&gt; reqs = parser.parse_file(\"requirements/prod.txt\")\n&gt;&gt;&gt; [r.name for r in reqs if r.editable]\n['my-local-package']\n</code></pre> Source code in <code>depkeeper/core/parser.py</code> Python<pre><code>def parse_file(\n    self,\n    file_path: Union[str, Path],\n    is_constraint_file: bool = False,\n    _parent_directory_path: Optional[Path] = None,\n) -&gt; List[Requirement]:\n    \"\"\"Parse a requirements file from disk.\n\n    Reads the file at *file_path*, processes all directives (``-r``,\n    ``-c``, ``-e``, ``--hash``), and returns a flat list of\n    :class:`Requirement` objects.  If *file_path* is relative and\n    *_parent_directory_path* is provided (internal use by ``-r``), the\n    path is resolved relative to the parent.\n\n    Circular include chains (``A.txt`` includes ``B.txt`` which\n    includes ``A.txt``) are detected and raise :exc:`ParseError`.\n\n    Args:\n        file_path: Path to the requirements file (absolute or relative).\n        is_constraint_file: If ``True``, all parsed requirements are\n            stored as constraints (via :attr:`_constraint_requirements`)\n            rather than returned.  Used internally by ``-c`` handlers.\n        _parent_directory_path: Internal parameter used when resolving\n            ``-r`` includes; the parent's directory is used as the base\n            for relative paths.\n\n    Returns:\n        List of :class:`Requirement` objects (empty if\n        *is_constraint_file* is ``True``).\n\n    Raises:\n        FileOperationError: The file does not exist or cannot be read.\n        ParseError: A circular include was detected or the file contains\n            invalid syntax.\n\n    Example::\n\n        &gt;&gt;&gt; parser = RequirementsParser()\n        &gt;&gt;&gt; reqs = parser.parse_file(\"requirements/prod.txt\")\n        &gt;&gt;&gt; [r.name for r in reqs if r.editable]\n        ['my-local-package']\n    \"\"\"\n    resolved_path = self._resolve_file_path(\n        file_path=Path(file_path),\n        parent_directory=_parent_directory_path,\n    )\n\n    self.logger.debug(\n        \"Parsing file: %s%s\",\n        resolved_path,\n        \" (constraint file)\" if is_constraint_file else \"\",\n    )\n\n    # Detect circular includes before reading\n    if resolved_path in self._included_files_stack:\n        cycle_path = \" -&gt; \".join(\n            str(p) for p in self._included_files_stack + [resolved_path]\n        )\n        self.logger.error(\"Circular dependency detected: %s\", cycle_path)\n        raise ParseError(\n            f\"Circular dependency detected: {cycle_path}\",\n            file_path=str(resolved_path),\n        )\n\n    file_content = safe_read_file(resolved_path)\n\n    self._included_files_stack.append(resolved_path)\n    try:\n        result = self.parse_string(\n            file_content,\n            source_file_path=str(resolved_path),\n            is_constraint_file=is_constraint_file,\n            _current_directory_path=resolved_path,\n        )\n        self.logger.debug(\n            \"Parsed %d requirement(s) from %s\",\n            len(result),\n            resolved_path.name,\n        )\n        return result\n    finally:\n        self._included_files_stack.pop()\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.RequirementsParser.parse_string","title":"parse_string","text":"Python<pre><code>parse_string(requirements_content: str, source_file_path: Optional[str] = None, is_constraint_file: bool = False, _current_directory_path: Optional[Path] = None) -&gt; List[Requirement]\n</code></pre> <p>Parse requirements from raw text content.</p> <p>Splits requirements_content into lines and processes each via :meth:<code>parse_line</code>.  Requirements loaded from <code>-r</code> includes are flattened into the result list.</p> PARAMETER DESCRIPTION <code>requirements_content</code> <p>Multi-line requirements text.</p> <p> TYPE: <code>str</code> </p> <code>source_file_path</code> <p>Optional file path for error messages (purely informational; does not affect parsing).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>is_constraint_file</code> <p>If <code>True</code>, all parsed requirements are stored in :attr:<code>_constraint_requirements</code> instead of being returned.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>_current_directory_path</code> <p>Internal parameter; the directory containing the \"file\" being parsed (used to resolve relative <code>-r</code> / <code>-c</code> paths).</p> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>List[Requirement]</code> <p>List of :class:<code>Requirement</code> objects.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; content = \"\"\"\n... flask&gt;=2.0\n... # A comment\n... requests&gt;=2.25.0\n... \"\"\"\n&gt;&gt;&gt; parser = RequirementsParser()\n&gt;&gt;&gt; reqs = parser.parse_string(content)\n&gt;&gt;&gt; [r.name for r in reqs]\n['flask', 'requests']\n</code></pre> Source code in <code>depkeeper/core/parser.py</code> Python<pre><code>def parse_string(\n    self,\n    requirements_content: str,\n    source_file_path: Optional[str] = None,\n    is_constraint_file: bool = False,\n    _current_directory_path: Optional[Path] = None,\n) -&gt; List[Requirement]:\n    \"\"\"Parse requirements from raw text content.\n\n    Splits *requirements_content* into lines and processes each via\n    :meth:`parse_line`.  Requirements loaded from ``-r`` includes are\n    flattened into the result list.\n\n    Args:\n        requirements_content: Multi-line requirements text.\n        source_file_path: Optional file path for error messages (purely\n            informational; does not affect parsing).\n        is_constraint_file: If ``True``, all parsed requirements are\n            stored in :attr:`_constraint_requirements` instead of being\n            returned.\n        _current_directory_path: Internal parameter; the directory\n            containing the \"file\" being parsed (used to resolve\n            relative ``-r`` / ``-c`` paths).\n\n    Returns:\n        List of :class:`Requirement` objects.\n\n    Example::\n\n        &gt;&gt;&gt; content = \\\"\\\"\\\"\n        ... flask&gt;=2.0\n        ... # A comment\n        ... requests&gt;=2.25.0\n        ... \\\"\\\"\\\"\n        &gt;&gt;&gt; parser = RequirementsParser()\n        &gt;&gt;&gt; reqs = parser.parse_string(content)\n        &gt;&gt;&gt; [r.name for r in reqs]\n        ['flask', 'requests']\n    \"\"\"\n    parsed_requirements: List[Requirement] = []\n    total_lines = len(requirements_content.splitlines())\n    self.logger.debug(\n        \"Parsing %d line(s)%s\",\n        total_lines,\n        f\" from {source_file_path}\" if source_file_path else \"\",\n    )\n\n    for line_number, line_text in enumerate(\n        requirements_content.splitlines(), start=1\n    ):\n        parse_result = self.parse_line(\n            line_text,\n            line_number,\n            source_file_path,\n            _current_directory_path=_current_directory_path,\n        )\n\n        if parse_result is None:\n            # Comment or blank line\n            continue\n\n        if isinstance(parse_result, list):\n            # Nested requirements from -r directive\n            self.logger.debug(\n                \"Included %d requirement(s) from directive on line %d\",\n                len(parse_result),\n                line_number,\n            )\n            parsed_requirements.extend(parse_result)\n        elif isinstance(parse_result, Requirement):\n            if is_constraint_file:\n                # Store in constraint map instead of returning\n                self._constraint_requirements[parse_result.name] = parse_result\n                self.logger.debug(\n                    \"Stored constraint: %s %s\",\n                    parse_result.name,\n                    parse_result.specs,\n                )\n            else:\n                parsed_requirements.append(parse_result)\n\n    self.logger.debug(\n        \"Completed parsing: %d requirement(s)\", len(parsed_requirements)\n    )\n    return parsed_requirements\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.RequirementsParser.parse_line","title":"parse_line","text":"Python<pre><code>parse_line(line_text: str, line_number: int, source_file_path: Optional[str] = None, _current_directory_path: Optional[Path] = None) -&gt; Optional[Union[Requirement, List[Requirement]]]\n</code></pre> <p>Parse a single line from a requirements file.</p> <p>Handles all pip-supported line types:</p> <ul> <li>Blank lines and <code>#</code> comments \u2192 <code>None</code></li> <li><code>-r file.txt</code> \u2192 <code>List[Requirement]</code> (nested parse)</li> <li><code>-c file.txt</code> \u2192 <code>None</code> (side-effect: populates constraints)</li> <li><code>-e &lt;url-or-path&gt;</code> \u2192 editable :class:<code>Requirement</code></li> <li><code>pkg==1.0 --hash sha256:...</code> \u2192 :class:<code>Requirement</code> with hashes</li> <li>Standard PEP 508 specs \u2192 :class:<code>Requirement</code></li> </ul> PARAMETER DESCRIPTION <code>line_text</code> <p>Raw line text (may include leading/trailing whitespace).</p> <p> TYPE: <code>str</code> </p> <code>line_number</code> <p>Line number (1-indexed) for error reporting.</p> <p> TYPE: <code>int</code> </p> <code>source_file_path</code> <p>Optional source file path for error messages.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>_current_directory_path</code> <p>Internal; directory of the file being parsed (used to resolve relative <code>-r</code> / <code>-c</code> paths).</p> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Optional[Union[Requirement, List[Requirement]]]</code> <ul> <li><code>None</code> for comments, blank lines, or <code>-c</code> directives.</li> </ul> <code>Optional[Union[Requirement, List[Requirement]]]</code> <ul> <li><code>List[Requirement]</code> when the line is a <code>-r</code> include.</li> </ul> <code>Optional[Union[Requirement, List[Requirement]]]</code> <ul> <li><code>Requirement</code> for all other valid package specs.</li> </ul> RAISES DESCRIPTION <code>ParseError</code> <p>The line contains invalid syntax or a directive that cannot be processed.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; parser = RequirementsParser()\n&gt;&gt;&gt; parser.parse_line(\"requests&gt;=2.25.0\", 1)\n&lt;Requirement requests&gt;=2.25.0&gt;\n&gt;&gt;&gt; parser.parse_line(\"# comment\", 2) is None\nTrue\n&gt;&gt;&gt; parser.parse_line(\"-r base.txt\", 3)  # returns List[Requirement]\n</code></pre> Source code in <code>depkeeper/core/parser.py</code> Python<pre><code>def parse_line(\n    self,\n    line_text: str,\n    line_number: int,\n    source_file_path: Optional[str] = None,\n    _current_directory_path: Optional[Path] = None,\n) -&gt; Optional[Union[Requirement, List[Requirement]]]:\n    \"\"\"Parse a single line from a requirements file.\n\n    Handles all pip-supported line types:\n\n    - Blank lines and ``#`` comments \u2192 ``None``\n    - ``-r file.txt`` \u2192 ``List[Requirement]`` (nested parse)\n    - ``-c file.txt`` \u2192 ``None`` (side-effect: populates constraints)\n    - ``-e &lt;url-or-path&gt;`` \u2192 editable :class:`Requirement`\n    - ``pkg==1.0 --hash sha256:...`` \u2192 :class:`Requirement` with hashes\n    - Standard PEP 508 specs \u2192 :class:`Requirement`\n\n    Args:\n        line_text: Raw line text (may include leading/trailing whitespace).\n        line_number: Line number (1-indexed) for error reporting.\n        source_file_path: Optional source file path for error messages.\n        _current_directory_path: Internal; directory of the file being\n            parsed (used to resolve relative ``-r`` / ``-c`` paths).\n\n    Returns:\n        - ``None`` for comments, blank lines, or ``-c`` directives.\n        - ``List[Requirement]`` when the line is a ``-r`` include.\n        - ``Requirement`` for all other valid package specs.\n\n    Raises:\n        ParseError: The line contains invalid syntax or a directive\n            that cannot be processed.\n\n    Example::\n\n        &gt;&gt;&gt; parser = RequirementsParser()\n        &gt;&gt;&gt; parser.parse_line(\"requests&gt;=2.25.0\", 1)\n        &lt;Requirement requests&gt;=2.25.0&gt;\n        &gt;&gt;&gt; parser.parse_line(\"# comment\", 2) is None\n        True\n        &gt;&gt;&gt; parser.parse_line(\"-r base.txt\", 3)  # returns List[Requirement]\n    \"\"\"\n    stripped_line = line_text.strip()\n\n    # Blank lines and pure comments are skipped\n    if not stripped_line or stripped_line.startswith(\"#\"):\n        return None\n\n    # Extract inline comment (everything after a non-URL '#')\n    requirement_spec, inline_comment = self._extract_inline_comment(stripped_line)\n\n    # \u2500\u2500 Handle -r / --requirement (include another file) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    if requirement_spec.startswith((INCLUDE_DIRECTIVE, INCLUDE_DIRECTIVE_LONG)):\n        return self._handle_include_directive(\n            requirement_spec,\n            line_number,\n            source_file_path,\n            _current_directory_path,\n        )\n\n    # \u2500\u2500 Handle -c / --constraint (load constraints) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    if requirement_spec.startswith(\n        (CONSTRAINT_DIRECTIVE, CONSTRAINT_DIRECTIVE_LONG)\n    ):\n        self._handle_constraint_directive(\n            requirement_spec,\n            line_number,\n            source_file_path,\n            _current_directory_path,\n        )\n        return None  # constraints are stored, not returned\n\n    # Strip quotes that may wrap the entire spec\n    requirement_spec = self._remove_surrounding_quotes(requirement_spec)\n\n    # \u2500\u2500 Check for -e / --editable flag \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    is_editable = requirement_spec.startswith(\n        (EDITABLE_DIRECTIVE, EDITABLE_DIRECTIVE_LONG)\n    )\n    if is_editable:\n        # Extract everything after \"-e \" or \"--editable \"\n        requirement_spec = (\n            requirement_spec.split(None, 1)[1] if \" \" in requirement_spec else \"\"\n        )\n\n    # \u2500\u2500 Extract --hash directives \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    hash_values: List[str] = re.findall(r\"--hash[=\\s]+(\\S+)\", requirement_spec)\n    if hash_values:\n        # Remove all --hash tokens from the spec\n        requirement_spec = \" \".join(\n            token\n            for token in requirement_spec.split()\n            if not token.startswith(HASH_DIRECTIVE)\n        )\n\n    # \u2500\u2500 Dispatch to appropriate builder \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    url_components = self._parse_direct_url(requirement_spec)\n    if url_components:\n        parsed_requirement = self._build_url_based_requirement(\n            url_string=requirement_spec,\n            url_components=url_components,\n            is_editable=is_editable,\n            hash_values=hash_values,\n            inline_comment=inline_comment,\n            original_line=line_text,\n            line_number=line_number,\n        )\n\n    elif local_path_components := self._parse_local_file_path(requirement_spec):\n        parsed_requirement = self._build_local_path_requirement(\n            path_components=local_path_components,\n            current_directory=_current_directory_path,\n            is_editable=is_editable,\n            hash_values=hash_values,\n            inline_comment=inline_comment,\n            original_line=line_text,\n            line_number=line_number,\n        )\n\n    else:\n        # Standard PEP 508 package specifier\n        parsed_requirement = self._build_standard_pep508_requirement(\n            requirement_spec=requirement_spec,\n            is_editable=is_editable,\n            hash_values=hash_values,\n            inline_comment=inline_comment,\n            original_line=line_text,\n            line_number=line_number,\n            source_file_path=source_file_path,\n        )\n\n    # Apply any constraint loaded via -c directive\n    return self._apply_constraint_to_requirement(parsed_requirement)\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.RequirementsParser.get_constraints","title":"get_constraints","text":"Python<pre><code>get_constraints() -&gt; Dict[str, Requirement]\n</code></pre> <p>Return a copy of all constraint requirements loaded via <code>-c</code>.</p> RETURNS DESCRIPTION <code>Dict[str, Requirement]</code> <p>Dictionary mapping normalised package names to their constraint</p> <code>Dict[str, Requirement]</code> <p>class:<code>Requirement</code> objects.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; parser = RequirementsParser()\n&gt;&gt;&gt; parser.parse_file(\"requirements.txt\")  # includes -c constraints.txt\n&gt;&gt;&gt; constraints = parser.get_constraints()\n&gt;&gt;&gt; constraints.get(\"django\")\n&lt;Requirement django==3.2&gt;\n</code></pre> Source code in <code>depkeeper/core/parser.py</code> Python<pre><code>def get_constraints(self) -&gt; Dict[str, Requirement]:\n    \"\"\"Return a copy of all constraint requirements loaded via ``-c``.\n\n    Returns:\n        Dictionary mapping normalised package names to their constraint\n        :class:`Requirement` objects.\n\n    Example::\n\n        &gt;&gt;&gt; parser = RequirementsParser()\n        &gt;&gt;&gt; parser.parse_file(\"requirements.txt\")  # includes -c constraints.txt\n        &gt;&gt;&gt; constraints = parser.get_constraints()\n        &gt;&gt;&gt; constraints.get(\"django\")\n        &lt;Requirement django==3.2&gt;\n    \"\"\"\n    return self._constraint_requirements.copy()\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.RequirementsParser.reset","title":"reset","text":"Python<pre><code>reset() -&gt; None\n</code></pre> <p>Clear all internal state (include stack and constraints).</p> <p>Call this before reusing the parser on a new, unrelated set of files to prevent cross-contamination.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; parser = RequirementsParser()\n&gt;&gt;&gt; parser.parse_file(\"projectA/requirements.txt\")\n&gt;&gt;&gt; parser.reset()\n&gt;&gt;&gt; parser.parse_file(\"projectB/requirements.txt\")  # clean slate\n</code></pre> Source code in <code>depkeeper/core/parser.py</code> Python<pre><code>def reset(self) -&gt; None:\n    \"\"\"Clear all internal state (include stack and constraints).\n\n    Call this before reusing the parser on a new, unrelated set of\n    files to prevent cross-contamination.\n\n    Example::\n\n        &gt;&gt;&gt; parser = RequirementsParser()\n        &gt;&gt;&gt; parser.parse_file(\"projectA/requirements.txt\")\n        &gt;&gt;&gt; parser.reset()\n        &gt;&gt;&gt; parser.parse_file(\"projectB/requirements.txt\")  # clean slate\n    \"\"\"\n    self._included_files_stack = []\n    self._constraint_requirements = {}\n</code></pre>"},{"location":"reference/python-api/#versionchecker","title":"VersionChecker","text":"<p>Async package version checker with strict major version boundary enforcement. Recommendations never cross major version boundaries -- if the current version is <code>2.x.x</code>, the recommended version will always be <code>2.y.z</code>, never <code>3.0.0</code>.</p> <p>All network I/O is delegated to <code>PyPIDataStore</code>, which guarantees that each unique package is fetched at most once.</p> Python<pre><code>from depkeeper.core import VersionChecker, PyPIDataStore\nfrom depkeeper.utils import HTTPClient\n\nasync def main():\n    async with HTTPClient() as http:\n        store = PyPIDataStore(http)\n        checker = VersionChecker(data_store=store)\n\n        # Check single package\n        pkg = await checker.get_package_info(\"requests\", current_version=\"2.28.0\")\n        print(f\"Latest: {pkg.latest_version}\")\n        print(f\"Recommended: {pkg.recommended_version}\")\n\n        # Check multiple packages concurrently\n        packages = await checker.check_packages(requirements)\n</code></pre>"},{"location":"reference/python-api/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Default Description <code>data_store</code> <code>PyPIDataStore</code> Required Shared PyPI metadata cache <code>infer_version_from_constraints</code> <code>bool</code> <code>True</code> Infer current version from range constraints like <code>&gt;=2.0</code>"},{"location":"reference/python-api/#methods_1","title":"Methods","text":"<p>Async package version checker with strict major version boundaries.</p> <p>Fetches metadata from PyPI (via the shared data store) and determines the highest Python-compatible version for each package, strictly respecting major-version boundaries when a current version is known. Unlike the base implementation, this checker will never recommend crossing a major version boundary, even if a newer major exists.</p> <p>All network I/O is delegated to data_store, which guarantees that each unique package is fetched at most once.</p> PARAMETER DESCRIPTION <code>data_store</code> <p>Shared PyPI metadata cache. Required.</p> <p> TYPE: <code>PyPIDataStore</code> </p> <code>infer_version_from_constraints</code> <p>When <code>True</code> and a requirement has no pinned version (<code>==</code>), attempt to infer a \"current\" version from range constraints like <code>&gt;=2.0</code>. Defaults to <code>True</code>.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If data_store is <code>None</code>.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; async with HTTPClient() as http:\n...     store   = PyPIDataStore(http)\n...     checker = VersionChecker(data_store=store)\n...     pkg     = await checker.get_package_info(\"flask\", current_version=\"2.0.0\")\n...     print(pkg.recommended_version)\n'2.3.3'  # Never 3.x.x, even if 3.0.0 is available\n</code></pre> Source code in <code>depkeeper/core/checker.py</code> Python<pre><code>def __init__(\n    self,\n    data_store: PyPIDataStore,\n    infer_version_from_constraints: bool = True,\n) -&gt; None:\n    if data_store is None:\n        raise TypeError(\n            \"data_store must not be None; pass a PyPIDataStore instance\"\n        )\n\n    self.data_store: PyPIDataStore = data_store\n    self.infer_version_from_constraints: bool = infer_version_from_constraints\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.VersionChecker-functions","title":"Functions","text":""},{"location":"reference/python-api/#depkeeper.core.VersionChecker.get_package_info","title":"get_package_info  <code>async</code>","text":"Python<pre><code>get_package_info(name: str, current_version: Optional[str] = None) -&gt; Package\n</code></pre> <p>Fetch metadata and compute a recommended version for name.</p> <p>CRITICAL: Recommendations NEVER cross major version boundaries. If current_version is <code>2.x.x</code>, the recommended version will be <code>2.y.z</code> (never <code>3.0.0</code>), even if <code>3.0.0</code> is the latest available version on PyPI.</p> <p>Calls :meth:<code>PyPIDataStore.get_package_data</code> (which may trigger a network fetch or return cached data), then applies the strict major-boundary recommendation algorithm to choose the best upgrade target.</p> PARAMETER DESCRIPTION <code>name</code> <p>Package name (any casing / separator style).</p> <p> TYPE: <code>str</code> </p> <code>current_version</code> <p>The version currently installed (if known). When provided, the recommendation stays within the same major version. If no compatible version exists in that major, stays on current version rather than crossing the boundary.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>A</code> <p>class:<code>Package</code> with <code>latest_version</code>,</p> <p> TYPE: <code>Package</code> </p> <code>Package</code> <p><code>recommended_version</code>, and metadata fields populated.</p> RAISES DESCRIPTION <code>PyPIError</code> <p>The package does not exist on PyPI or the API returned an unexpected status.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; pkg = await checker.get_package_info(\"requests\", current_version=\"2.25.0\")\n&gt;&gt;&gt; pkg.latest_version\n'2.31.0'\n&gt;&gt;&gt; pkg.recommended_version\n'2.31.0'  # Stays in major version 2\n</code></pre> Source code in <code>depkeeper/core/checker.py</code> Python<pre><code>async def get_package_info(\n    self,\n    name: str,\n    current_version: Optional[str] = None,\n) -&gt; Package:\n    \"\"\"Fetch metadata and compute a recommended version for *name*.\n\n    **CRITICAL**: Recommendations **NEVER** cross major version boundaries.\n    If *current_version* is ``2.x.x``, the recommended version will be\n    ``2.y.z`` (never ``3.0.0``), even if ``3.0.0`` is the latest available\n    version on PyPI.\n\n    Calls :meth:`PyPIDataStore.get_package_data` (which may trigger a\n    network fetch or return cached data), then applies the strict\n    major-boundary recommendation algorithm to choose the best upgrade\n    target.\n\n    Args:\n        name: Package name (any casing / separator style).\n        current_version: The version currently installed (if known).\n            When provided, the recommendation stays within the same\n            major version. If no compatible version exists in that\n            major, stays on current version rather than crossing\n            the boundary.\n\n    Returns:\n        A :class:`Package` with ``latest_version``,\n        ``recommended_version``, and metadata fields populated.\n\n    Raises:\n        PyPIError: The package does not exist on PyPI or the API\n            returned an unexpected status.\n\n    Example::\n\n        &gt;&gt;&gt; pkg = await checker.get_package_info(\"requests\", current_version=\"2.25.0\")\n        &gt;&gt;&gt; pkg.latest_version\n        '2.31.0'\n        &gt;&gt;&gt; pkg.recommended_version\n        '2.31.0'  # Stays in major version 2\n    \"\"\"\n    try:\n        pkg_data = await self.data_store.get_package_data(name)\n    except PyPIError:\n        # Package not found or API error \u2014 return unavailable stub\n        logger.warning(\"Package '%s' unavailable; creating stub\", name)\n        return self.create_unavailable_package(name, current_version)\n\n    return self._build_package_from_data(pkg_data, current_version)\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.VersionChecker.check_packages","title":"check_packages  <code>async</code>","text":"Python<pre><code>check_packages(requirements: List[Requirement]) -&gt; List[Package]\n</code></pre> <p>Check multiple packages concurrently.</p> <p>For each requirement, extracts the current version (via :meth:<code>extract_current_version</code>) and calls :meth:<code>get_package_info</code>. Errors for individual packages are caught and replaced with unavailable stubs so that one bad package does not block the rest.</p> PARAMETER DESCRIPTION <code>requirements</code> <p>Parsed requirements from a requirements file.</p> <p> TYPE: <code>List[Requirement]</code> </p> RETURNS DESCRIPTION <code>List[Package]</code> <p>List of :class:<code>Package</code> objects, one per requirement.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; requirements = parser.parse_file(\"requirements.txt\")\n&gt;&gt;&gt; packages = await checker.check_packages(requirements)\n&gt;&gt;&gt; [p.name for p in packages if p.recommended_version]\n['flask', 'requests', 'click']\n</code></pre> Source code in <code>depkeeper/core/checker.py</code> Python<pre><code>async def check_packages(\n    self,\n    requirements: List[Requirement],\n) -&gt; List[Package]:\n    \"\"\"Check multiple packages concurrently.\n\n    For each requirement, extracts the current version (via\n    :meth:`extract_current_version`) and calls :meth:`get_package_info`.\n    Errors for individual packages are caught and replaced with\n    unavailable stubs so that one bad package does not block the rest.\n\n    Args:\n        requirements: Parsed requirements from a requirements file.\n\n    Returns:\n        List of :class:`Package` objects, one per requirement.\n\n    Example::\n\n        &gt;&gt;&gt; requirements = parser.parse_file(\"requirements.txt\")\n        &gt;&gt;&gt; packages = await checker.check_packages(requirements)\n        &gt;&gt;&gt; [p.name for p in packages if p.recommended_version]\n        ['flask', 'requests', 'click']\n    \"\"\"\n    tasks = [self._create_package_check_task(req) for req in requirements]\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    return self._process_check_results(requirements, results)\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.VersionChecker.extract_current_version","title":"extract_current_version","text":"Python<pre><code>extract_current_version(req: Requirement) -&gt; Optional[str]\n</code></pre> <p>Infer a \"current\" version from a requirement's version specifiers.</p> <p>Heuristic:</p> <ol> <li>If the requirement has exactly one specifier and it is <code>==</code>,    return that version (pinned).</li> <li>If :attr:<code>infer_version_from_constraints</code> is <code>False</code>, stop here.</li> <li>Otherwise, scan for the first <code>&gt;=</code>, <code>&gt;</code>, or <code>~=</code> specifier    and return its version. This treats <code>&gt;=2.0</code> as \"currently on    2.0\" for major-version boundary purposes.</li> </ol> PARAMETER DESCRIPTION <code>req</code> <p>A parsed :class:<code>Requirement</code>.</p> <p> TYPE: <code>Requirement</code> </p> RETURNS DESCRIPTION <code>Optional[str]</code> <p>The inferred version string, or <code>None</code> when inference is not</p> <code>Optional[str]</code> <p>possible.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; req1 = Requirement(name=\"flask\", specs=[(\"==\", \"2.0.0\")], ...)\n&gt;&gt;&gt; checker.extract_current_version(req1)\n'2.0.0'\n\n&gt;&gt;&gt; req2 = Requirement(name=\"flask\", specs=[(\"&gt;=\", \"2.0\"), (\"&lt;\", \"3\")], ...)\n&gt;&gt;&gt; checker.extract_current_version(req2)\n'2.0'\n\n&gt;&gt;&gt; req3 = Requirement(name=\"flask\", specs=[], ...)\n&gt;&gt;&gt; checker.extract_current_version(req3) is None\nTrue\n</code></pre> Source code in <code>depkeeper/core/checker.py</code> Python<pre><code>def extract_current_version(\n    self,\n    req: Requirement,\n) -&gt; Optional[str]:\n    \"\"\"Infer a \"current\" version from a requirement's version specifiers.\n\n    Heuristic:\n\n    1. If the requirement has exactly one specifier and it is ``==``,\n       return that version (pinned).\n    2. If :attr:`infer_version_from_constraints` is ``False``, stop here.\n    3. Otherwise, scan for the first ``&gt;=``, ``&gt;``, or ``~=`` specifier\n       and return its version. This treats ``&gt;=2.0`` as \"currently on\n       2.0\" for major-version boundary purposes.\n\n    Args:\n        req: A parsed :class:`Requirement`.\n\n    Returns:\n        The inferred version string, or ``None`` when inference is not\n        possible.\n\n    Example::\n\n        &gt;&gt;&gt; req1 = Requirement(name=\"flask\", specs=[(\"==\", \"2.0.0\")], ...)\n        &gt;&gt;&gt; checker.extract_current_version(req1)\n        '2.0.0'\n\n        &gt;&gt;&gt; req2 = Requirement(name=\"flask\", specs=[(\"&gt;=\", \"2.0\"), (\"&lt;\", \"3\")], ...)\n        &gt;&gt;&gt; checker.extract_current_version(req2)\n        '2.0'\n\n        &gt;&gt;&gt; req3 = Requirement(name=\"flask\", specs=[], ...)\n        &gt;&gt;&gt; checker.extract_current_version(req3) is None\n        True\n    \"\"\"\n    if not req.specs:\n        return None\n\n    # Exact pin: treat as the current version\n    if len(req.specs) == 1 and req.specs[0][0] == \"==\":\n        return req.specs[0][1]\n\n    if not self.infer_version_from_constraints:\n        return None\n\n    # Infer from range lower-bound operators\n    for operator, version in req.specs:\n        if operator in (\"&gt;=\", \"&gt;\", \"~=\"):\n            return version\n\n    return None\n</code></pre>"},{"location":"reference/python-api/#pypidatastore","title":"PyPIDataStore","text":"<p>Async-safe, per-process cache for PyPI package metadata. Each unique package name triggers at most one HTTP request to <code>/pypi/{pkg}/json</code>. A semaphore limits concurrent outbound fetches, and double-checked locking prevents duplicate requests when multiple coroutines request the same package simultaneously.</p> Python<pre><code>from depkeeper.core import PyPIDataStore\nfrom depkeeper.utils import HTTPClient\n\nasync def main():\n    async with HTTPClient() as http:\n        store = PyPIDataStore(http, concurrent_limit=10)\n\n        # Fetch package data\n        data = await store.get_package_data(\"requests\")\n        print(f\"Latest: {data.latest_version}\")\n        print(f\"All versions: {data.all_versions[:5]}\")\n\n        # Prefetch multiple packages concurrently\n        await store.prefetch_packages([\"flask\", \"click\", \"jinja2\"])\n\n        # Get cached data (no network call)\n        cached = store.get_cached_package(\"flask\")\n\n        # Get dependencies for a specific version\n        deps = await store.get_version_dependencies(\"flask\", \"2.3.0\")\n</code></pre>"},{"location":"reference/python-api/#constructor-parameters_1","title":"Constructor Parameters","text":"Parameter Type Default Description <code>http_client</code> <code>HTTPClient</code> Required Pre-configured async HTTP client <code>concurrent_limit</code> <code>int</code> <code>10</code> Maximum concurrent PyPI fetches"},{"location":"reference/python-api/#methods_2","title":"Methods","text":"<p>Async-safe, per-process cache for PyPI package metadata.</p> <p>Each unique (normalised) package name triggers at most one HTTP request to <code>/pypi/{pkg}/json</code>.  A :class:<code>asyncio.Semaphore</code> limits concurrent outbound fetches, and a double-checked lock inside the semaphore prevents thundering-herd duplicates when several coroutines request the same package simultaneously.</p> PARAMETER DESCRIPTION <code>http_client</code> <p>A pre-configured :class:<code>HTTPClient</code> instance (owns connection pool / session).</p> <p> TYPE: <code>HTTPClient</code> </p> <code>concurrent_limit</code> <p>Maximum number of PyPI fetches that may be in-flight at once.  Defaults to <code>10</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> <p>Example::</p> Text Only<pre><code>async with HTTPClient() as client:\n    store = PyPIDataStore(client, concurrent_limit=5)\n\n    # warm the cache for several packages at once\n    await store.prefetch_packages([\"flask\", \"click\", \"jinja2\"])\n\n    # subsequent calls return instantly from cache\n    flask = await store.get_package_data(\"flask\")\n    print(flask.latest_version)\n</code></pre> Source code in <code>depkeeper/core/data_store.py</code> Python<pre><code>def __init__(\n    self,\n    http_client: HTTPClient,\n    concurrent_limit: int = 10,\n) -&gt; None:\n    self.http_client = http_client\n    self._semaphore = asyncio.Semaphore(concurrent_limit)\n\n    # Primary cache: normalised name \u2192 parsed package snapshot\n    self._package_data: Dict[str, PyPIPackageData] = {}\n\n    # Secondary cache: \"name==version\" \u2192 dependency list (avoids\n    # repeated per-version fetches even after the main cache is warm)\n    self._version_deps_cache: Dict[str, List[str]] = {}\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.PyPIDataStore-functions","title":"Functions","text":""},{"location":"reference/python-api/#depkeeper.core.PyPIDataStore.get_package_data","title":"get_package_data  <code>async</code>","text":"Python<pre><code>get_package_data(name: str) -&gt; PyPIPackageData\n</code></pre> <p>Fetch (or return cached) metadata for name.</p> <p>Uses double-checked locking: the first check is lock-free; if the package is missing a second check runs inside the semaphore so that only one coroutine actually performs the HTTP call.</p> PARAMETER DESCRIPTION <code>name</code> <p>PyPI package name (any casing / underscore style).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>A</code> <p>class:<code>PyPIPackageData</code> populated from the latest PyPI</p> <p> TYPE: <code>PyPIPackageData</code> </p> <code>PyPIPackageData</code> <p>JSON response.</p> RAISES DESCRIPTION <code>PyPIError</code> <p>The package does not exist on PyPI or the API returned an unexpected status code.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; data = await store.get_package_data(\"Requests\")\n&gt;&gt;&gt; data.name\n'requests'\n&gt;&gt;&gt; data.latest_version\n'2.31.0'\n</code></pre> Source code in <code>depkeeper/core/data_store.py</code> Python<pre><code>async def get_package_data(self, name: str) -&gt; PyPIPackageData:\n    \"\"\"Fetch (or return cached) metadata for *name*.\n\n    Uses double-checked locking: the first check is lock-free; if the\n    package is missing a second check runs *inside* the semaphore so\n    that only one coroutine actually performs the HTTP call.\n\n    Args:\n        name: PyPI package name (any casing / underscore style).\n\n    Returns:\n        A :class:`PyPIPackageData` populated from the latest PyPI\n        JSON response.\n\n    Raises:\n        PyPIError: The package does not exist on PyPI or the API\n            returned an unexpected status code.\n\n    Example::\n\n        &gt;&gt;&gt; data = await store.get_package_data(\"Requests\")\n        &gt;&gt;&gt; data.name\n        'requests'\n        &gt;&gt;&gt; data.latest_version\n        '2.31.0'\n    \"\"\"\n    normalized = _normalize(name)\n\n    # Fast path \u2014 already cached (no lock needed)\n    if normalized in self._package_data:\n        return self._package_data[normalized]\n\n    async with self._semaphore:\n        # Second check \u2014 another coroutine may have populated while we waited\n        if normalized in self._package_data:\n            return self._package_data[normalized]\n\n        data = await self._fetch_from_pypi(name)\n        pkg_data = self._parse_package_data(name, data)\n        self._package_data[normalized] = pkg_data\n        return pkg_data\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.PyPIDataStore.prefetch_packages","title":"prefetch_packages  <code>async</code>","text":"Python<pre><code>prefetch_packages(names: List[str]) -&gt; None\n</code></pre> <p>Concurrently warm the cache for a batch of packages.</p> <p>Errors for individual packages are silenced so that one bad package name does not prevent the rest from being cached.</p> PARAMETER DESCRIPTION <code>names</code> <p>Package names to prefetch.</p> <p> TYPE: <code>List[str]</code> </p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; await store.prefetch_packages([\"numpy\", \"pandas\", \"scipy\"])\n# subsequent get_package_data calls for these return instantly\n</code></pre> Source code in <code>depkeeper/core/data_store.py</code> Python<pre><code>async def prefetch_packages(self, names: List[str]) -&gt; None:\n    \"\"\"Concurrently warm the cache for a batch of packages.\n\n    Errors for individual packages are silenced so that one bad\n    package name does not prevent the rest from being cached.\n\n    Args:\n        names: Package names to prefetch.\n\n    Example::\n\n        &gt;&gt;&gt; await store.prefetch_packages([\"numpy\", \"pandas\", \"scipy\"])\n        # subsequent get_package_data calls for these return instantly\n    \"\"\"\n    await asyncio.gather(\n        *(self.get_package_data(name) for name in names),\n        return_exceptions=True,  # swallow per-package failures\n    )\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.PyPIDataStore.get_version_dependencies","title":"get_version_dependencies  <code>async</code>","text":"Python<pre><code>get_version_dependencies(name: str, version: str) -&gt; List[str]\n</code></pre> <p>Return the base dependencies for a specific version of name.</p> <p>Resolution order (fastest first):</p> <ol> <li>Per-version dependency cache (<code>_version_deps_cache</code>).</li> <li>Already-populated fields inside the cached    :class:<code>PyPIPackageData</code> (<code>latest_dependencies</code> or    <code>dependencies_cache</code>).</li> <li>A targeted <code>/pypi/{name}/{version}/json</code> fetch, guarded by    the semaphore and a second cache check.</li> </ol> PARAMETER DESCRIPTION <code>name</code> <p>Package name.</p> <p> TYPE: <code>str</code> </p> <code>version</code> <p>Exact version string, e.g. <code>\"1.2.3\"</code>.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of PEP-508 dependency specifiers with extras and</p> <code>List[str]</code> <p>environment markers stripped.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; deps = await store.get_version_dependencies(\"flask\", \"2.3.0\")\n&gt;&gt;&gt; deps\n['Werkzeug&gt;=2.0', 'Jinja2&gt;=3.0', ...]\n</code></pre> Source code in <code>depkeeper/core/data_store.py</code> Python<pre><code>async def get_version_dependencies(\n    self,\n    name: str,\n    version: str,\n) -&gt; List[str]:\n    \"\"\"Return the base dependencies for a specific version of *name*.\n\n    Resolution order (fastest first):\n\n    1. Per-version dependency cache (``_version_deps_cache``).\n    2. Already-populated fields inside the cached\n       :class:`PyPIPackageData` (``latest_dependencies`` or\n       ``dependencies_cache``).\n    3. A targeted ``/pypi/{name}/{version}/json`` fetch, guarded by\n       the semaphore and a second cache check.\n\n    Args:\n        name: Package name.\n        version: Exact version string, e.g. ``\"1.2.3\"``.\n\n    Returns:\n        List of PEP-508 dependency specifiers with extras and\n        environment markers stripped.\n\n    Example::\n\n        &gt;&gt;&gt; deps = await store.get_version_dependencies(\"flask\", \"2.3.0\")\n        &gt;&gt;&gt; deps\n        ['Werkzeug&gt;=2.0', 'Jinja2&gt;=3.0', ...]\n    \"\"\"\n    normalized = _normalize(name)\n    cache_key = f\"{normalized}=={version}\"\n\n    # \u2500\u2500 layer 1: flat version-deps cache \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    if cache_key in self._version_deps_cache:\n        return self._version_deps_cache[cache_key]\n\n    # \u2500\u2500 layer 2: already inside PyPIPackageData \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    pkg_data = self._package_data.get(normalized)\n    if pkg_data:\n        if version == pkg_data.latest_version:\n            self._version_deps_cache[cache_key] = pkg_data.latest_dependencies\n            return pkg_data.latest_dependencies\n\n        if version in pkg_data.dependencies_cache:\n            deps = pkg_data.dependencies_cache[version]\n            self._version_deps_cache[cache_key] = deps\n            return deps\n\n    # \u2500\u2500 layer 3: network fetch (double-checked) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    async with self._semaphore:\n        if cache_key in self._version_deps_cache:\n            return self._version_deps_cache[cache_key]\n\n        deps = await self._fetch_version_dependencies(name, version)\n        self._version_deps_cache[cache_key] = deps\n\n        # Back-fill the package-level cache so future reads skip this path\n        if pkg_data:\n            pkg_data.dependencies_cache[version] = deps\n\n        return deps\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.PyPIDataStore.get_cached_package","title":"get_cached_package","text":"Python<pre><code>get_cached_package(name: str) -&gt; Optional[PyPIPackageData]\n</code></pre> <p>Return cached data for name without triggering a fetch.</p> PARAMETER DESCRIPTION <code>name</code> <p>Package name (any casing / underscore style).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[PyPIPackageData]</code> <p>The cached :class:<code>PyPIPackageData</code>, or <code>None</code> if the</p> <code>Optional[PyPIPackageData]</code> <p>package has not been fetched yet.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; store.get_cached_package(\"flask\")  # after a prior fetch\nPyPIPackageData(name='flask', latest_version='3.0.0', ...)\n&gt;&gt;&gt; store.get_cached_package(\"unknown\")\nNone\n</code></pre> Source code in <code>depkeeper/core/data_store.py</code> Python<pre><code>def get_cached_package(self, name: str) -&gt; Optional[PyPIPackageData]:\n    \"\"\"Return cached data for *name* without triggering a fetch.\n\n    Args:\n        name: Package name (any casing / underscore style).\n\n    Returns:\n        The cached :class:`PyPIPackageData`, or ``None`` if the\n        package has not been fetched yet.\n\n    Example::\n\n        &gt;&gt;&gt; store.get_cached_package(\"flask\")  # after a prior fetch\n        PyPIPackageData(name='flask', latest_version='3.0.0', ...)\n        &gt;&gt;&gt; store.get_cached_package(\"unknown\")\n        None\n    \"\"\"\n    return self._package_data.get(_normalize(name))\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.PyPIDataStore.get_versions","title":"get_versions","text":"Python<pre><code>get_versions(name: str) -&gt; List[str]\n</code></pre> <p>Return cached stable versions for name (newest first).</p> <p>Returns an empty list when name has not been fetched yet.</p> PARAMETER DESCRIPTION <code>name</code> <p>Package name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of version strings, or <code>[]</code>.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; store.get_versions(\"flask\")\n['3.0.0', '2.3.3', '2.3.2', ...]\n</code></pre> Source code in <code>depkeeper/core/data_store.py</code> Python<pre><code>def get_versions(self, name: str) -&gt; List[str]:\n    \"\"\"Return cached stable versions for *name* (newest first).\n\n    Returns an empty list when *name* has not been fetched yet.\n\n    Args:\n        name: Package name.\n\n    Returns:\n        List of version strings, or ``[]``.\n\n    Example::\n\n        &gt;&gt;&gt; store.get_versions(\"flask\")\n        ['3.0.0', '2.3.3', '2.3.2', ...]\n    \"\"\"\n    pkg = self.get_cached_package(name)\n    return pkg.all_versions if pkg else []\n</code></pre>"},{"location":"reference/python-api/#pypipackagedata","title":"PyPIPackageData","text":"<p>Immutable-by-convention snapshot of one PyPI package, populated by <code>PyPIDataStore</code>. Contains version lists, Python compatibility data, and dependency caches.</p>"},{"location":"reference/python-api/#attributes","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>str</code> Normalized package name <code>latest_version</code> <code>Optional[str]</code> Latest version on PyPI <code>latest_requires_python</code> <code>Optional[str]</code> Python requirement for latest version <code>latest_dependencies</code> <code>List[str]</code> Base dependencies of latest version <code>all_versions</code> <code>List[str]</code> Stable versions, newest first <code>parsed_versions</code> <code>List[Tuple[str, Version]]</code> Parsed version objects, descending <code>python_requirements</code> <code>Dict[str, Optional[str]]</code> Version to <code>requires_python</code> mapping <code>dependencies_cache</code> <code>Dict[str, List[str]]</code> Per-version dependency lists"},{"location":"reference/python-api/#methods_3","title":"Methods","text":"Method Returns Description <code>get_versions_in_major(major)</code> <code>List[str]</code> Stable versions sharing a given major number <code>is_python_compatible(version, python_version)</code> <code>bool</code> Check if a package version supports a Python version <code>get_python_compatible_versions(python_version, major=None)</code> <code>List[str]</code> Stable versions compatible with a Python version"},{"location":"reference/python-api/#dependencyanalyzer","title":"DependencyAnalyzer","text":"<p>Resolves dependency conflicts with strict major version boundary enforcement. The analyzer builds a dependency graph, detects version conflicts, and iteratively adjusts recommendations until a conflict-free set is found or the iteration limit is reached.</p> Python<pre><code>from depkeeper.core import DependencyAnalyzer, PyPIDataStore\nfrom depkeeper.utils import HTTPClient\n\nasync def main():\n    async with HTTPClient() as http:\n        store = PyPIDataStore(http)\n        analyzer = DependencyAnalyzer(data_store=store)\n\n        # Resolve conflicts\n        result = await analyzer.resolve_and_annotate_conflicts(packages)\n\n        # Check results\n        for name, resolution in result.resolved_versions.items():\n            print(f\"{name}: {resolution.original} -&gt; {resolution.resolved}\")\n            print(f\"  Status: {resolution.status}\")\n\n        # Summary\n        print(result.summary())\n</code></pre>"},{"location":"reference/python-api/#methods_4","title":"Methods","text":"<p>Detect and resolve version conflicts with strict major version boundaries.</p> <p>This analyzer enhances the base conflict resolution by ensuring that no package is ever upgraded or downgraded across major version boundaries during conflict resolution. This prevents breaking changes from being inadvertently introduced.</p> <p>The analyzer works exclusively through a :class:<code>PyPIDataStore</code> instance, which guarantees that every <code>/pypi/{pkg}/json</code> call is made at most once. All public entry points are <code>async</code>.</p> PARAMETER DESCRIPTION <code>data_store</code> <p>Shared PyPI data store. Required \u2014 the class has no independent HTTP path.</p> <p> TYPE: <code>PyPIDataStore</code> </p> <code>concurrent_limit</code> <p>Upper bound on in-flight PyPI fetches. Forwarded to the internal semaphore. Defaults to <code>10</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> RAISES DESCRIPTION <code>TypeError</code> <p>If data_store is <code>None</code>.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; async with HTTPClient() as http:\n...     store    = PyPIDataStore(http)\n...     analyzer = DependencyAnalyzer(data_store=store)\n...     result   = await analyzer.resolve_and_annotate_conflicts(pkgs)\n...     print(result.summary())\n</code></pre> Source code in <code>depkeeper/core/dependency_analyzer.py</code> Python<pre><code>def __init__(\n    self,\n    data_store: PyPIDataStore,\n    concurrent_limit: int = 10,\n) -&gt; None:\n    if data_store is None:\n        raise TypeError(\n            \"data_store must not be None; pass a PyPIDataStore instance\"\n        )\n    self.data_store: PyPIDataStore = data_store\n    self._semaphore: asyncio.Semaphore = asyncio.Semaphore(concurrent_limit)\n</code></pre>"},{"location":"reference/python-api/#depkeeper.core.DependencyAnalyzer-functions","title":"Functions","text":""},{"location":"reference/python-api/#depkeeper.core.DependencyAnalyzer.resolve_and_annotate_conflicts","title":"resolve_and_annotate_conflicts  <code>async</code>","text":"Python<pre><code>resolve_and_annotate_conflicts(packages: List[Package]) -&gt; ResolutionResult\n</code></pre> <p>Resolve conflicts while strictly respecting major version boundaries.</p> <p>Algorithm outline:</p> <ol> <li>Build an update set mapping each package name to its    proposed version (<code>recommended_version</code> if available,    otherwise <code>current_version</code>). Recommended versions already    respect major version boundaries.</li> <li>Prefetch metadata for every package in one concurrent burst.</li> <li>Loop up to :data:<code>_MAX_RESOLUTION_ITERATIONS</code> times:</li> </ol> <p>a. Scan for cross-conflicts in the current update set.    b. If none remain, stop \u2014 the set is self-consistent.    c. Attempt resolution within major version boundaries only:</p> Text Only<pre><code>  - Try to find a compatible source version within its current major\n  - If that fails, try to constrain the target within its current major\n  - If both fail, revert both packages to their current versions\n</code></pre> <p>d. Break early when no progress is made.</p> <ol> <li>Annotate each :class:<code>Package</code> with its final version and any    unresolved :class:<code>Conflict</code> objects.</li> <li>Return a :class:<code>ResolutionResult</code> with complete details.</li> </ol> PARAMETER DESCRIPTION <code>packages</code> <p>Mutable list of :class:<code>Package</code> objects. Each object is updated in place with the resolved version and conflict metadata.</p> <p> TYPE: <code>List[Package]</code> </p> RETURNS DESCRIPTION <code>ResolutionResult</code> <p>class:<code>ResolutionResult</code> containing the final version for each</p> <code>ResolutionResult</code> <p>package, conflict details, and resolution statistics.</p> <p>Example::</p> Text Only<pre><code>&gt;&gt;&gt; result = await analyzer.resolve_and_annotate_conflicts(pkgs)\n&gt;&gt;&gt; print(result.summary())\n&gt;&gt;&gt; for pkg_name, info in result.resolved_versions.items():\n...     if info.was_changed():\n...         print(f\"{pkg_name}: {info.original} \u2192 {info.resolved}\")\n</code></pre> Source code in <code>depkeeper/core/dependency_analyzer.py</code> Python<pre><code>async def resolve_and_annotate_conflicts(\n    self,\n    packages: List[Package],\n) -&gt; ResolutionResult:\n    \"\"\"Resolve conflicts while strictly respecting major version boundaries.\n\n    Algorithm outline:\n\n    1. Build an *update set* mapping each package name to its\n       proposed version (``recommended_version`` if available,\n       otherwise ``current_version``). Recommended versions already\n       respect major version boundaries.\n    2. Prefetch metadata for every package in one concurrent burst.\n    3. Loop up to :data:`_MAX_RESOLUTION_ITERATIONS` times:\n\n       a. Scan for cross-conflicts in the current update set.\n       b. If none remain, stop \u2014 the set is self-consistent.\n       c. Attempt resolution within major version boundaries only:\n\n          - Try to find a compatible source version within its current major\n          - If that fails, try to constrain the target within its current major\n          - If both fail, revert both packages to their current versions\n\n       d. Break early when no progress is made.\n\n    4. Annotate each :class:`Package` with its final version and any\n       unresolved :class:`Conflict` objects.\n    5. Return a :class:`ResolutionResult` with complete details.\n\n    Args:\n        packages: Mutable list of :class:`Package` objects. Each\n            object is updated in place with the resolved version and\n            conflict metadata.\n\n    Returns:\n        :class:`ResolutionResult` containing the final version for each\n        package, conflict details, and resolution statistics.\n\n    Example::\n\n        &gt;&gt;&gt; result = await analyzer.resolve_and_annotate_conflicts(pkgs)\n        &gt;&gt;&gt; print(result.summary())\n        &gt;&gt;&gt; for pkg_name, info in result.resolved_versions.items():\n        ...     if info.was_changed():\n        ...         print(f\"{pkg_name}: {info.original} \u2192 {info.resolved}\")\n    \"\"\"\n    # \u2500\u2500 initialise update set \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    pkg_lookup: Dict[str, Package] = {pkg.name: pkg for pkg in packages}\n    update_set: Dict[str, Optional[str]] = {}\n    conflict_tracking: Dict[str, List[Conflict]] = {}\n\n    # Track original proposed versions for comparison\n    original_versions: Dict[str, Optional[str]] = {}\n\n    for pkg in packages:\n        # Use recommended version (which already respects major boundaries)\n        proposed = pkg.recommended_version or pkg.current_version\n        update_set[pkg.name] = proposed\n        original_versions[pkg.name] = proposed\n\n    # \u2500\u2500 warm the cache in one round-trip \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    await self.data_store.prefetch_packages([pkg.name for pkg in packages])\n\n    # \u2500\u2500 iterative conflict resolution \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    iterations_used = 0\n    converged = False\n\n    for iteration in range(_MAX_RESOLUTION_ITERATIONS):\n        iterations_used = iteration + 1\n        cross_conflicts = await self._find_cross_conflicts(packages, update_set)\n\n        if not cross_conflicts:\n            logger.debug(\n                \"Update set is conflict-free after %d iteration(s)\", iteration\n            )\n            converged = True\n            break\n\n        # Record every conflict for later annotation (with deduplication)\n        for conflict in cross_conflicts:\n            conflicts_list = conflict_tracking.setdefault(\n                conflict.target_package, []\n            )\n\n            # Deduplicate using conflict signature\n            conflict_key = (\n                conflict.source_package,\n                conflict.source_version,\n                conflict.required_spec,\n                conflict.conflicting_version,\n            )\n            existing_keys = {\n                (\n                    c.source_package,\n                    c.source_version,\n                    c.required_spec,\n                    c.conflicting_version,\n                )\n                for c in conflicts_list\n            }\n            if conflict_key not in existing_keys:\n                conflicts_list.append(conflict)\n\n        # Attempt resolution while respecting major version boundaries\n        resolved_any = await self._resolve_conflicts_within_major(\n            pkg_lookup, update_set, cross_conflicts\n        )\n\n        if not resolved_any:\n            # No version change was made \u2192 further iterations would\n            # produce the exact same conflict set; stop early.\n            logger.warning(\n                \"Conflict resolution stalled after %d iteration(s)\",\n                iteration + 1,\n            )\n            break\n    else:\n        # for/else: exhausted all iterations without breaking\n        logger.warning(\n            \"Conflict resolution did not converge within %d iterations\",\n            _MAX_RESOLUTION_ITERATIONS,\n        )\n\n    # \u2500\u2500 annotate packages and build resolution map \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    resolved_versions: Dict[str, PackageResolution] = {}\n    packages_with_conflicts = 0\n\n    for pkg in packages:\n        original = original_versions.get(pkg.name)\n        resolved = update_set.get(pkg.name)\n        conflicts = conflict_tracking.get(pkg.name, [])\n\n        # Determine resolution status\n        status = self._determine_status(pkg, original, resolved, conflicts)\n\n        # Find compatible alternative if there are conflicts\n        # (constrained to current major version only)\n        compatible_alt = None\n        if conflicts:\n            # Get current major version to constrain search\n            current_major = _get_major_version(pkg.current_version)\n\n            if current_major is not None:\n                # Only look within current major\n                available = self.data_store.get_versions(pkg.name)\n                available_in_major = [\n                    v for v in available if _get_major_version(v) == current_major\n                ]\n\n                conflict_set = ConflictSet(pkg.name)\n                for c in conflicts:\n                    conflict_set.add_conflict(c)\n\n                compatible_alt = self.find_compatible_version(\n                    conflict_set, available_in_major, pkg.current_version\n                )\n\n            packages_with_conflicts += 1\n\n        # Update the Package object itself\n        if resolved and resolved != pkg.recommended_version:\n            # Only update recommended_version if resolution changed it\n            pkg.recommended_version = (\n                resolved if resolved != pkg.current_version else pkg.current_version\n            )\n        if conflicts:\n            pkg.set_conflicts(conflicts, resolved_version=compatible_alt)\n\n        # Store resolution details\n        resolved_versions[pkg.name] = PackageResolution(\n            name=pkg.name,\n            original=original,\n            resolved=resolved,\n            status=status,\n            conflicts=conflicts,\n            compatible_alternative=compatible_alt,\n        )\n\n    return ResolutionResult(\n        resolved_versions=resolved_versions,\n        total_packages=len(packages),\n        packages_with_conflicts=packages_with_conflicts,\n        iterations_used=iterations_used,\n        converged=converged,\n    )\n</code></pre>"},{"location":"reference/python-api/#resolutionresult","title":"ResolutionResult","text":"<p>Complete result of dependency conflict resolution, returned by <code>DependencyAnalyzer.resolve_and_annotate_conflicts()</code>.</p>"},{"location":"reference/python-api/#attributes_1","title":"Attributes","text":"Attribute Type Description <code>resolved_versions</code> <code>Dict[str, PackageResolution]</code> Package name to resolution details <code>total_packages</code> <code>int</code> Total packages analyzed <code>packages_with_conflicts</code> <code>int</code> Packages that have conflicts <code>iterations_used</code> <code>int</code> Resolution iterations performed <code>converged</code> <code>bool</code> Whether resolution reached a stable state"},{"location":"reference/python-api/#methods_5","title":"Methods","text":"Method Returns Description <code>get_changed_packages()</code> <code>List[PackageResolution]</code> Packages whose version was changed <code>get_conflicts()</code> <code>List[PackageResolution]</code> Packages with unresolved conflicts <code>summary()</code> <code>str</code> Human-readable resolution summary"},{"location":"reference/python-api/#packageresolution","title":"PackageResolution","text":"<p>Resolution details for a single package within a <code>ResolutionResult</code>.</p>"},{"location":"reference/python-api/#attributes_2","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>str</code> Package name (normalized) <code>original</code> <code>Optional[str]</code> Initially proposed version <code>resolved</code> <code>Optional[str]</code> Final version after resolution <code>status</code> <code>ResolutionStatus</code> Why this version was chosen <code>conflicts</code> <code>List[Conflict]</code> Conflicts affecting this package <code>compatible_alternative</code> <code>Optional[str]</code> Best alternative version, if any"},{"location":"reference/python-api/#resolution-statuses","title":"Resolution Statuses","text":"Status Description <code>KEPT_RECOMMENDED</code> Original recommendation was conflict-free <code>UPGRADED</code> Successfully upgraded to a newer version <code>DOWNGRADED</code> Had to downgrade due to conflicts <code>KEPT_CURRENT</code> No safe upgrade found; stayed at current <code>CONSTRAINED</code> Version was constrained by another package"},{"location":"reference/python-api/#models","title":"Models","text":""},{"location":"reference/python-api/#requirement","title":"Requirement","text":"<p>Represents a single requirement line from a requirements file.</p> Python<pre><code>from depkeeper.models import Requirement\n\nreq = Requirement(\n    name=\"requests\",\n    specs=[(\"&gt;=\", \"2.28.0\"), (\"&lt;\", \"3.0.0\")],\n    extras=[\"security\"],\n    markers=\"python_version &gt;= '3.8'\",\n)\n\n# Convert to string\nprint(req.to_string())  # requests[security]&gt;=2.28.0,&lt;3.0.0; python_version &gt;= '3.8'\n\n# Update version (replaces all specifiers with ==new_version)\nupdated = req.update_version(\"2.31.0\")\nprint(updated)  # requests[security]==2.31.0; python_version &gt;= '3.8'\n</code></pre>"},{"location":"reference/python-api/#attributes_3","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>str</code> Canonical package name <code>specs</code> <code>List[Tuple[str, str]]</code> Version specifiers (operator, version) <code>extras</code> <code>List[str]</code> Optional extras to install <code>markers</code> <code>Optional[str]</code> Environment marker expression (PEP 508) <code>url</code> <code>Optional[str]</code> Direct URL or VCS source <code>editable</code> <code>bool</code> Whether this is an editable install (<code>-e</code>) <code>hashes</code> <code>List[str]</code> Hash values for verification <code>comment</code> <code>Optional[str]</code> Inline comment without the <code>#</code> prefix <code>line_number</code> <code>int</code> Original line number in the source file <code>raw_line</code> <code>Optional[str]</code> Original unmodified line text"},{"location":"reference/python-api/#methods_6","title":"Methods","text":"Method Returns Description <code>to_string(include_hashes=True, include_comment=True)</code> <code>str</code> Render canonical <code>requirements.txt</code> representation <code>update_version(new_version)</code> <code>str</code> Return requirement string updated to a new version"},{"location":"reference/python-api/#package","title":"Package","text":"<p>Represents a Python package with version state, update recommendations, and conflict tracking.</p> Python<pre><code>from depkeeper.models import Package\n\npkg = Package(\n    name=\"requests\",\n    current_version=\"2.28.0\",\n    latest_version=\"2.32.0\",\n    recommended_version=\"2.32.0\",\n)\n\n# Check status\nprint(pkg.has_update())        # True\nprint(pkg.requires_downgrade)  # False\nprint(pkg.has_conflicts())     # False\n\n# Serialization\nprint(pkg.to_json())\n</code></pre>"},{"location":"reference/python-api/#attributes_4","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>str</code> Normalized package name (PEP 503) <code>current_version</code> <code>Optional[str]</code> Currently installed or specified version <code>latest_version</code> <code>Optional[str]</code> Latest version on PyPI (informational) <code>recommended_version</code> <code>Optional[str]</code> Safe upgrade version within major boundary <code>metadata</code> <code>Dict[str, Any]</code> Package metadata from PyPI <code>conflicts</code> <code>List[Conflict]</code> Dependency conflicts affecting this package"},{"location":"reference/python-api/#properties-and-methods","title":"Properties and Methods","text":"Member Type Description <code>current</code> <code>Optional[Version]</code> Parsed current version <code>latest</code> <code>Optional[Version]</code> Parsed latest version <code>recommended</code> <code>Optional[Version]</code> Parsed recommended version <code>requires_downgrade</code> <code>bool</code> True if recommended version is lower than current <code>has_update()</code> <code>bool</code> True if recommended version is newer than current <code>has_conflicts()</code> <code>bool</code> True if dependency conflicts exist <code>set_conflicts(conflicts, resolved_version=None)</code> <code>None</code> Set conflicts and optionally update recommended version <code>get_conflict_summary()</code> <code>List[str]</code> Short, user-friendly conflict summaries <code>get_conflict_details()</code> <code>List[str]</code> Detailed conflict descriptions <code>get_status_summary()</code> <code>Tuple[str, str, str, Optional[str]]</code> Status, installed, latest, recommended <code>to_json()</code> <code>Dict[str, Any]</code> JSON-safe package representation"},{"location":"reference/python-api/#conflict","title":"Conflict","text":"<p>Represents a dependency conflict between two packages. This is a frozen dataclass (immutable after creation).</p> Python<pre><code>from depkeeper.models import Conflict\n\nconflict = Conflict(\n    source_package=\"flask\",\n    target_package=\"werkzeug\",\n    required_spec=\"&gt;=2.0,&lt;3.0\",\n    conflicting_version=\"3.0.0\",\n    source_version=\"2.3.0\",\n)\n\nprint(conflict.to_display_string())\n# flask==2.3.0 requires werkzeug&gt;=2.0,&lt;3.0\n</code></pre>"},{"location":"reference/python-api/#attributes_5","title":"Attributes","text":"Attribute Type Description <code>source_package</code> <code>str</code> Package declaring the dependency <code>target_package</code> <code>str</code> Package being constrained <code>required_spec</code> <code>str</code> Version specifier required by the source <code>conflicting_version</code> <code>str</code> Version that violates the requirement <code>source_version</code> <code>Optional[str]</code> Version of the source package"},{"location":"reference/python-api/#methods_7","title":"Methods","text":"Method Returns Description <code>to_display_string()</code> <code>str</code> Human-readable conflict description <code>to_short_string()</code> <code>str</code> Compact conflict summary <code>to_json()</code> <code>Dict[str, Optional[str]]</code> JSON-serializable representation"},{"location":"reference/python-api/#conflictset","title":"ConflictSet","text":"<p>Collection of conflicts affecting a single package. Provides utilities to find compatible versions.</p>"},{"location":"reference/python-api/#attributes_6","title":"Attributes","text":"Attribute Type Description <code>package_name</code> <code>str</code> Name of the affected package <code>conflicts</code> <code>List[Conflict]</code> Conflicts associated with this package"},{"location":"reference/python-api/#methods_8","title":"Methods","text":"Method Returns Description <code>add_conflict(conflict)</code> <code>None</code> Add a conflict to the set <code>has_conflicts()</code> <code>bool</code> True if any conflicts exist <code>get_max_compatible_version(available_versions)</code> <code>Optional[str]</code> Highest version compatible with all conflicts"},{"location":"reference/python-api/#utilities","title":"Utilities","text":""},{"location":"reference/python-api/#httpclient","title":"HTTPClient","text":"<p>Async HTTP client with retry logic, rate limiting, concurrency control, and PyPI-specific error handling. Uses httpx with HTTP/2 support.</p> Python<pre><code>from depkeeper.utils import HTTPClient\n\nasync def main():\n    async with HTTPClient(timeout=30, max_retries=3) as http:\n        # GET request\n        response = await http.get(\"https://pypi.org/pypi/requests/json\")\n\n        # GET with JSON parsing\n        data = await http.get_json(\"https://pypi.org/pypi/requests/json\")\n\n        # Batch concurrent JSON fetches\n        results = await http.batch_get_json([\n            \"https://pypi.org/pypi/flask/json\",\n            \"https://pypi.org/pypi/click/json\",\n        ])\n</code></pre>"},{"location":"reference/python-api/#constructor-parameters_2","title":"Constructor Parameters","text":"Parameter Type Default Description <code>timeout</code> <code>int</code> <code>30</code> Request timeout in seconds <code>max_retries</code> <code>int</code> <code>3</code> Maximum retry attempts <code>rate_limit_delay</code> <code>float</code> <code>0.0</code> Minimum delay between requests <code>verify_ssl</code> <code>bool</code> <code>True</code> Verify SSL certificates <code>user_agent</code> <code>Optional[str]</code> Auto-generated Custom User-Agent header <code>max_concurrency</code> <code>int</code> <code>10</code> Maximum concurrent requests"},{"location":"reference/python-api/#methods_9","title":"Methods","text":"Method Returns Description <code>get(url)</code> <code>httpx.Response</code> GET request with retry logic <code>post(url)</code> <code>httpx.Response</code> POST request with retry logic <code>get_json(url)</code> <code>Dict[str, Any]</code> GET and parse JSON response <code>batch_get_json(urls)</code> <code>Dict[str, Dict[str, Any]]</code> Concurrent JSON fetches <code>close()</code> <code>None</code> Close the HTTP client"},{"location":"reference/python-api/#console-utilities","title":"Console Utilities","text":"<p>User-facing output helpers built on the Rich library.</p> Python<pre><code>from depkeeper.utils import (\n    print_success,\n    print_error,\n    print_warning,\n    print_table,\n    confirm,\n    get_raw_console,\n)\n\n# Status messages\nprint_success(\"Operation completed!\")\nprint_error(\"Something went wrong\")\nprint_warning(\"Proceed with caution\")\n\n# Rich table from list of dicts\nprint_table(\n    data=[\n        {\"Name\": \"requests\", \"Version\": \"2.31.0\"},\n        {\"Name\": \"flask\", \"Version\": \"2.3.3\"},\n    ],\n    title=\"Packages\",\n)\n\n# User confirmation prompt\nif confirm(\"Apply 5 updates?\", default=False):\n    print(\"Applying...\")\n\n# Access underlying Rich Console\nconsole = get_raw_console()\n</code></pre>"},{"location":"reference/python-api/#functions","title":"Functions","text":"Function Parameters Description <code>print_success(message, prefix=\"[OK]\")</code> <code>str</code> Print a styled success message <code>print_error(message, prefix=\"[ERROR]\")</code> <code>str</code> Print a styled error message <code>print_warning(message, prefix=\"[WARNING]\")</code> <code>str</code> Print a styled warning message <code>print_table(data, headers=None, title=None, ...)</code> <code>List[Dict]</code> Render data as a Rich table <code>confirm(message, default=False)</code> <code>str, bool</code> Prompt for yes/no confirmation <code>get_raw_console()</code> Return the underlying Rich Console instance <code>reconfigure_console()</code> <code>None</code> Reset the global console (useful after changing <code>NO_COLOR</code>) <code>colorize_update_type(update_type)</code> <code>str</code> Return Rich-markup colored update type label"},{"location":"reference/python-api/#filesystem-utilities","title":"Filesystem Utilities","text":"<p>Safe file I/O helpers with backup, restore, and path validation support.</p> Python<pre><code>from depkeeper.utils import (\n    safe_read_file,\n    safe_write_file,\n    create_backup,\n    restore_backup,\n    create_timestamped_backup,\n    find_requirements_files,\n    validate_path,\n)\n\n# Read a file safely (with size limit)\ncontent = safe_read_file(\"requirements.txt\")\n\n# Write with automatic backup\nbackup_path = safe_write_file(\"requirements.txt\", new_content, create_backup=True)\n\n# Find all requirements files in a directory\nfiles = find_requirements_files(\".\", recursive=True)\n\n# Validate a path stays within a base directory\nresolved = validate_path(\"../requirements.txt\", base_dir=\"/project\")\n</code></pre>"},{"location":"reference/python-api/#functions_1","title":"Functions","text":"Function Returns Description <code>safe_read_file(file_path, max_size=None, encoding=\"utf-8\")</code> <code>str</code> Read a text file with optional size limit <code>safe_write_file(file_path, content, create_backup=True)</code> <code>Optional[Path]</code> Atomic write with optional backup; returns backup path <code>create_backup(file_path)</code> <code>Path</code> Create a timestamped backup of a file <code>restore_backup(backup_path, target_path=None)</code> <code>None</code> Restore a file from a backup <code>create_timestamped_backup(file_path)</code> <code>Path</code> Create a backup with <code>{stem}.{timestamp}.backup{suffix}</code> format <code>find_requirements_files(directory=\".\", recursive=True)</code> <code>List[Path]</code> Find requirements files in a directory <code>validate_path(path, base_dir=None)</code> <code>Path</code> Resolve and validate a path; raises <code>FileOperationError</code> if outside <code>base_dir</code>"},{"location":"reference/python-api/#logging-utilities","title":"Logging Utilities","text":"<p>Centralized logging setup for depkeeper.</p> Python<pre><code>from depkeeper.utils import (\n    get_logger,\n    setup_logging,\n    disable_logging,\n    is_logging_configured,\n)\n\n# Get a named logger\nlogger = get_logger(\"my_module\")\nlogger.info(\"Processing started\")\n\n# Configure logging level\nsetup_logging(verbosity=2)  # DEBUG level\n\n# Check if logging has been configured\nif not is_logging_configured():\n    setup_logging(verbosity=0)\n\n# Suppress all logging output\ndisable_logging()\n</code></pre>"},{"location":"reference/python-api/#functions_2","title":"Functions","text":"Function Returns Description <code>get_logger(name=None)</code> <code>logging.Logger</code> Get a named logger under the <code>depkeeper</code> namespace <code>setup_logging(verbosity=0)</code> <code>None</code> Configure logging level (0=WARNING, 1=INFO, 2=DEBUG) <code>is_logging_configured()</code> <code>bool</code> Check if logging has already been set up <code>disable_logging()</code> <code>None</code> Suppress all depkeeper log output"},{"location":"reference/python-api/#version-utilities","title":"Version Utilities","text":"<p>Helpers for classifying version changes using PEP 440 parsing.</p> Python<pre><code>from depkeeper.utils import get_update_type\n\nget_update_type(\"1.0.0\", \"2.0.0\")   # \"major\"\nget_update_type(\"1.0.0\", \"1.1.0\")   # \"minor\"\nget_update_type(\"1.0.0\", \"1.0.1\")   # \"patch\"\nget_update_type(None, \"1.0.0\")       # \"new\"\nget_update_type(\"1.0.0\", \"1.0.0\")   # \"same\"\nget_update_type(\"2.0.0\", \"1.0.0\")   # \"downgrade\"\n</code></pre>"},{"location":"reference/python-api/#functions_3","title":"Functions","text":"Function Returns Description <code>get_update_type(current_version, target_version)</code> <code>str</code> Classify the update type between two versions <p>Return values: <code>\"major\"</code>, <code>\"minor\"</code>, <code>\"patch\"</code>, <code>\"new\"</code>, <code>\"same\"</code>, <code>\"downgrade\"</code>, <code>\"update\"</code>, <code>\"unknown\"</code></p>"},{"location":"reference/python-api/#exceptions","title":"Exceptions","text":"<p>All exceptions inherit from <code>DepKeeperError</code> and support structured metadata via the <code>details</code> attribute.</p> <p>Exception hierarchy:</p> <ul> <li><code>DepKeeperError</code> (base)<ul> <li><code>ParseError</code></li> <li><code>NetworkError</code><ul> <li><code>PyPIError</code></li> </ul> </li> <li><code>FileOperationError</code></li> </ul> </li> </ul> Exception Description Key Attributes <code>DepKeeperError</code> Base exception for all depkeeper errors <code>message</code>, <code>details</code> <code>ParseError</code> Requirements file parsing failures <code>line_number</code>, <code>line_content</code>, <code>file_path</code> <code>NetworkError</code> HTTP or network operation failures <code>url</code>, <code>status_code</code>, <code>response_body</code> <code>PyPIError</code> PyPI API-specific failures <code>package_name</code> (inherits <code>NetworkError</code>) <code>FileOperationError</code> File system operation failures <code>file_path</code>, <code>operation</code>, <code>original_error</code>"},{"location":"reference/python-api/#complete-example","title":"Complete Example","text":"Python<pre><code>#!/usr/bin/env python3\n\"\"\"Check and update dependencies programmatically.\"\"\"\n\nimport asyncio\n\nfrom depkeeper.core import (\n    RequirementsParser,\n    VersionChecker,\n    DependencyAnalyzer,\n    PyPIDataStore,\n)\nfrom depkeeper.utils import HTTPClient\n\n\nasync def analyze_requirements(file_path: str):\n    \"\"\"Analyze a requirements file and report on updates.\"\"\"\n\n    # Step 1: Parse requirements\n    parser = RequirementsParser()\n    requirements = parser.parse_file(file_path)\n    print(f\"Found {len(requirements)} packages\\n\")\n\n    async with HTTPClient() as http:\n        # Step 2: Create shared data store\n        store = PyPIDataStore(http)\n\n        # Step 3: Check versions\n        checker = VersionChecker(data_store=store)\n        packages = await checker.check_packages(requirements)\n\n        # Step 4: Resolve conflicts\n        analyzer = DependencyAnalyzer(data_store=store)\n        result = await analyzer.resolve_and_annotate_conflicts(packages)\n\n        # Step 5: Report results\n        print(f\"Converged: {result.converged} ({result.iterations_used} iterations)\")\n        print(f\"Conflicts: {result.packages_with_conflicts}\\n\")\n\n        for pkg in packages:\n            if pkg.has_update():\n                print(f\"  {pkg.name}: {pkg.current_version} -&gt; {pkg.recommended_version}\")\n\n    return packages\n\n\nif __name__ == \"__main__\":\n    asyncio.run(analyze_requirements(\"requirements.txt\"))\n</code></pre>"},{"location":"reference/python-api/#configuration","title":"Configuration","text":""},{"location":"reference/python-api/#depkeeperconfig","title":"DepKeeperConfig","text":"<p>Dataclass representing a parsed and validated configuration file. All fields carry defaults, so an empty or missing configuration file produces a fully usable config object.</p> Python<pre><code>from depkeeper.config import load_config, discover_config_file\n\n# Auto-discover and load (depkeeper.toml or pyproject.toml)\nconfig = load_config()\n\n# Load from explicit path\nconfig = load_config(Path(\"/project/depkeeper.toml\"))\n\n# Access values\nprint(config.check_conflicts)           # True\nprint(config.strict_version_matching)   # False\n</code></pre>"},{"location":"reference/python-api/#functions_4","title":"Functions","text":"<p>Configuration file loader for depkeeper.</p> <p>Handles discovery, loading, parsing, and validation of configuration files. Supports two formats:</p> <ul> <li><code>depkeeper.toml</code> \u2014 settings under <code>[depkeeper]</code> table</li> <li><code>pyproject.toml</code> \u2014 settings under <code>[tool.depkeeper]</code> table</li> </ul> <p>Discovery order:</p> <ol> <li>Explicit path from <code>--config</code> or <code>DEPKEEPER_CONFIG</code></li> <li><code>depkeeper.toml</code> in current directory</li> <li><code>pyproject.toml</code> with <code>[tool.depkeeper]</code> section</li> </ol> <p>Configuration precedence: defaults &lt; config file &lt; environment &lt; CLI args.</p> <p>Typical usage::</p> Text Only<pre><code>config = load_config()  # Auto-discover\nconfig = load_config(Path(\"custom.toml\"))  # Explicit path\n</code></pre> <p>Example (<code>depkeeper.toml</code>)::</p> Text Only<pre><code>[depkeeper]\ncheck_conflicts = true\nstrict_version_matching = false\n</code></pre>"},{"location":"reference/python-api/#depkeeper.config-functions","title":"Functions","text":""},{"location":"reference/python-api/#depkeeper.config.discover_config_file","title":"discover_config_file","text":"Python<pre><code>discover_config_file(explicit_path: Optional[Path] = None) -&gt; Optional[Path]\n</code></pre> <p>Find the configuration file to load.</p> <p>Search order:</p> <ol> <li><code>explicit_path</code> (from <code>--config</code> or <code>DEPKEEPER_CONFIG</code>)</li> <li><code>depkeeper.toml</code> in current directory</li> <li><code>pyproject.toml</code> with <code>[tool.depkeeper]</code> section in current directory</li> </ol> <p>Validates <code>pyproject.toml</code> contains depkeeper section before using it.</p> PARAMETER DESCRIPTION <code>explicit_path</code> <p>Explicit config path. If provided, must exist.</p> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Optional[Path]</code> <p>Resolved path to config file, or <code>None</code> if not found.</p> RAISES DESCRIPTION <code>ConfigError</code> <p>Explicit path provided but does not exist.</p> Source code in <code>depkeeper/config.py</code> Python<pre><code>def discover_config_file(explicit_path: Optional[Path] = None) -&gt; Optional[Path]:\n    \"\"\"Find the configuration file to load.\n\n    Search order:\n\n    1. ``explicit_path`` (from ``--config`` or ``DEPKEEPER_CONFIG``)\n    2. ``depkeeper.toml`` in current directory\n    3. ``pyproject.toml`` with ``[tool.depkeeper]`` section in current directory\n\n    Validates ``pyproject.toml`` contains depkeeper section before using it.\n\n    Args:\n        explicit_path: Explicit config path. If provided, must exist.\n\n    Returns:\n        Resolved path to config file, or ``None`` if not found.\n\n    Raises:\n        ConfigError: Explicit path provided but does not exist.\n    \"\"\"\n    # 1. Explicit path takes priority\n    if explicit_path is not None:\n        resolved = explicit_path.resolve()\n        if not resolved.is_file():\n            raise ConfigError(\n                f\"Configuration file not found: {explicit_path}\",\n                config_path=str(explicit_path),\n            )\n        logger.debug(\"Using explicit config: %s\", resolved)\n        return resolved\n\n    cwd = Path.cwd()\n\n    # 2. depkeeper.toml in current directory\n    depkeeper_toml = cwd / \"depkeeper.toml\"\n    if depkeeper_toml.is_file():\n        logger.debug(\"Found depkeeper.toml: %s\", depkeeper_toml)\n        return depkeeper_toml\n\n    # 3. pyproject.toml with [tool.depkeeper] section\n    pyproject_toml = cwd / \"pyproject.toml\"\n    if pyproject_toml.is_file():\n        if _pyproject_has_depkeeper_section(pyproject_toml):\n            logger.debug(\"Found [tool.depkeeper] in pyproject.toml: %s\", pyproject_toml)\n            return pyproject_toml\n\n    logger.debug(\"No configuration file found\")\n    return None\n</code></pre>"},{"location":"reference/python-api/#depkeeper.config.load_config","title":"load_config","text":"Python<pre><code>load_config(config_path: Optional[Path] = None) -&gt; DepKeeperConfig\n</code></pre> <p>Load and validate depkeeper configuration.</p> <p>Discovers config file (or uses provided path), parses and validates it. Returns config with defaults if no file found.</p> <p>Handles both <code>depkeeper.toml</code> and <code>pyproject.toml</code> formats.</p> PARAMETER DESCRIPTION <code>config_path</code> <p>Explicit path to config file. If <code>None</code>, uses auto-discovery (see :func:<code>discover_config_file</code>).</p> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Validated</code> <p>class:<code>DepKeeperConfig</code> with values from file or defaults.</p> <p> TYPE: <code>DepKeeperConfig</code> </p> RAISES DESCRIPTION <code>ConfigError</code> <p>File cannot be parsed, has unknown keys, or invalid values.</p> Source code in <code>depkeeper/config.py</code> Python<pre><code>def load_config(config_path: Optional[Path] = None) -&gt; DepKeeperConfig:\n    \"\"\"Load and validate depkeeper configuration.\n\n    Discovers config file (or uses provided path), parses and validates it.\n    Returns config with defaults if no file found.\n\n    Handles both ``depkeeper.toml`` and ``pyproject.toml`` formats.\n\n    Args:\n        config_path: Explicit path to config file. If ``None``, uses\n            auto-discovery (see :func:`discover_config_file`).\n\n    Returns:\n        Validated :class:`DepKeeperConfig` with values from file or defaults.\n\n    Raises:\n        ConfigError: File cannot be parsed, has unknown keys, or invalid values.\n    \"\"\"\n    resolved = discover_config_file(config_path)\n\n    if resolved is None:\n        logger.debug(\"No config file found, using defaults\")\n        return DepKeeperConfig()\n\n    logger.info(\"Loading configuration from %s\", resolved)\n    raw = _read_toml(resolved)\n\n    # Extract the depkeeper-specific section\n    if resolved.name == \"pyproject.toml\":\n        section = raw.get(\"tool\", {}).get(\"depkeeper\", {})\n    else:\n        # depkeeper.toml \u2014 settings live under [depkeeper]\n        section = raw.get(\"depkeeper\", {})\n\n    if not section:\n        logger.debug(\"Config file found but no depkeeper section \u2014 using defaults\")\n        return DepKeeperConfig(source_path=resolved)\n\n    config = _parse_section(section, config_path=str(resolved))\n    config.source_path = resolved\n\n    logger.debug(\"Loaded configuration: %s\", config.to_log_dict())\n    return config\n</code></pre>"},{"location":"reference/python-api/#class","title":"Class","text":""},{"location":"reference/python-api/#depkeeper.config.DepKeeperConfig","title":"DepKeeperConfig  <code>dataclass</code>","text":"Python<pre><code>DepKeeperConfig(check_conflicts: bool = DEFAULT_CHECK_CONFLICTS, strict_version_matching: bool = DEFAULT_STRICT_VERSION_MATCHING, source_path: Optional[Path] = None)\n</code></pre> <p>Parsed and validated depkeeper configuration.</p> <p>Contains settings from <code>depkeeper.toml</code> or <code>pyproject.toml</code>. All fields have defaults, so empty config files are valid.</p> ATTRIBUTE DESCRIPTION <code>check_conflicts</code> <p>Enable dependency conflict resolution. When <code>True</code>, analyzes transitive dependencies to avoid conflicts.</p> <p> TYPE: <code>bool</code> </p> <code>strict_version_matching</code> <p>Only consider exact pins (<code>==</code>) as current versions. Ignores range constraints like <code>&gt;=2.0</code>.</p> <p> TYPE: <code>bool</code> </p> <code>source_path</code> <p>Path to loaded config file, or <code>None</code> if using defaults.</p> <p> TYPE: <code>Optional[Path]</code> </p>"},{"location":"reference/python-api/#depkeeper.config.DepKeeperConfig-functions","title":"Functions","text":""},{"location":"reference/python-api/#depkeeper.config.DepKeeperConfig.to_log_dict","title":"to_log_dict","text":"Python<pre><code>to_log_dict() -&gt; Dict[str, Any]\n</code></pre> <p>Return configuration as dictionary for debug logging.</p> <p>Excludes <code>source_path</code> metadata.</p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Dictionary of configuration option names to values.</p> Source code in <code>depkeeper/config.py</code> Python<pre><code>def to_log_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Return configuration as dictionary for debug logging.\n\n    Excludes ``source_path`` metadata.\n\n    Returns:\n        Dictionary of configuration option names to values.\n    \"\"\"\n    return {\n        \"check_conflicts\": self.check_conflicts,\n        \"strict_version_matching\": self.strict_version_matching,\n    }\n</code></pre>"},{"location":"reference/python-api/#exception","title":"Exception","text":""},{"location":"reference/python-api/#depkeeper.config.ConfigError","title":"ConfigError","text":"Python<pre><code>ConfigError(message: str, *, config_path: Optional[str] = None, option: Optional[str] = None)\n</code></pre> <p>               Bases: <code>DepKeeperError</code></p> <p>Raised when a configuration file is invalid or cannot be loaded.</p> PARAMETER DESCRIPTION <code>message</code> <p>Human-readable description of the configuration problem.</p> <p> TYPE: <code>str</code> </p> <code>config_path</code> <p>Path to the configuration file that caused the error.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>option</code> <p>The specific configuration option that is invalid, if applicable.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>depkeeper/exceptions.py</code> Python<pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    config_path: Optional[str] = None,\n    option: Optional[str] = None,\n) -&gt; None:\n    details: MutableMapping[str, Any] = {}\n    _add_if(details, \"config_path\", config_path)\n    _add_if(details, \"option\", option)\n\n    super().__init__(message, details)\n\n    self.config_path = config_path\n    self.option = option\n</code></pre>"},{"location":"reference/python-api/#see-also","title":"See Also","text":"<ul> <li>Getting Started -- Quick start guide</li> <li>CLI Reference -- Command-line interface</li> <li>Configuration Guide -- Configuration guide</li> <li>Configuration Options -- Full options reference</li> <li>Contributing -- Development guide</li> </ul>"}]}